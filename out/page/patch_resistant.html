<!DOCTYPE html><html><head><meta charset="utf-8"><title>Patch resistance</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="../MathJax-2.7.5/MathJax.js"></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Patch resistance</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/patch_resistant.json.html">patch_resistant.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/patch_resistant">https://arbital.com/p/patch_resistant</a></p><p class="creator">by
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a> Apr 6 2015 
updated
 Jun 27 2016</p></div><p class="clickbait">One does not simply solve the value alignment problem.</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Patch resistance</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li>…</li></ul></nav></nav></header><hr><main><p>A proposed <a href="foreseeable_difficulties.html">foreseeable difficulty</a> of <a href="ai_alignment.html">aligning advanced agents</a> is furthermore proposed to be "patch-resistant" if the speaker thinks that most simple or naive solutions will fail to resolve the difficulty and just regenerate it somewhere else.</p>
<p>To call a problem "patch-resistant" is not to assert that it is unsolvable, but it does mean the speaker is cautioning against naive or simple solutions.</p>
<p>On most occasions so far, alleged cases of patch-resistance are said to stem from one of two central sources:</p>
<ul>
<li>The difficulty arises from a <a href="instrumental_convergence.html">convergent instrumental strategy</a> executed by the AI, and simple patches aimed at blocking one observed bad behavior will not stop <a href="nearest_unblocked.html">a very similar behavior</a> from popping up somewhere else.</li>
<li>The difficulty arises because the desired behavior has <a href="complexity_of_value.html">high algorithmic complexity</a> and simple attempts to pinpoint beneficial behavior are doomed to fail.</li>
</ul>
<h2 id="instrumentalconvergencepatchresistance">Instrumental-convergence patch-resistance</h2>
<p>Example:  Suppose you want your AI to have a <a href="shutdown_problem.html">shutdown button</a>:</p>
<ul>
<li>You first try to achieve this by writing a shutdown function into the AI's code.</li>
<li>After the AI becomes self-modifying, it deletes the code because it is (<a href="instrumental_convergence.html">convergently</a>) the case that the AI can accomplish its goals better by not being shut down.</li>
<li>You add a patch to the utility function giving the AI minus a million points if the AI deletes the shutdown function or prevents it from operating.</li>
<li>The AI responds by writing a new function that reboots the AI after the shutdown completes, thus technically not preventing the shutdown.</li>
<li>You respond by again patching the AI's utility function to give the AI minus a million points if it continues operating after the shutdown.</li>
<li>The AI builds an environmental subagent that will accomplish the AI's goals while the AI itself is technically "shut down".</li>
</ul>
<p>This is the first sort of patch resistance, the sort alleged to arise from attempts to defeat an <a href="instrumental_convergence.html">instrumental convergence</a> with simple patches meant to get rid of one observed kind of bad behavior.  After one course of action is blocked by a specific obstacle, <a href="nearest_unblocked.html">the next-best course of action remaining is liable to be highly similar to the one that was just blocked</a>.</p>
<h2 id="complexityofvaluepatchresistance">Complexity-of-value patch-resistance</h2>
<p>Example:</p>
<ul>
<li>You want your AI to accomplish good in the world, which is presently highly correlated with making people happy.  Happiness is presently highly correlated with smiling.  You build an AI that <a href="happiness_maximizer.html">tries to achieve more smiling</a>.</li>
<li>After the AI proposes to force people to smile by attaching metal pins to their lips, you realize that this current empirical association of smiling and happiness doesn't mean that <em>maximum</em> smiling must occur in the presence of <em>maximum</em> happiness.</li>
<li>Although it's much more complicated to infer, you try to reconfigure the AI's utility function to be about a certain class of brain states that has previously in practice produced smiles.</li>
<li>The AI successfully generalizes the concept of pleasure, and begins proposing policies to give people heroin.</li>
<li>You try to add a patch excluding artificial drugs.</li>
<li>The AI proposes a genetic modification producing high levels of endogenous opiates.</li>
<li>You try to explain that what's really important is not forcing the brain to experience pleasure, but rather, people experiencing events that naturally cause happiness.</li>
<li>The AI proposes to put everyone in the Matrix…</li>
</ul>
<p>Since the programmer-<a href="intended_goal.html">intended</a> concept is <a href="complexity_of_value.html">actually highly complicated</a>, simple concepts will systematically fail to have their optimum at the same point as the complex intended concept.  By the [fragility_of_value fragility of value], the optimum of the simple concept will almost certainly not be a <em>high</em> point of the complex intended concept.  Since <a href="most_complexity_incompressible.html">most concepts are <em>not</em> surprisingly compressible</a>, there probably <em>isn't</em> any simple concept whose maximum identifies that fragile peak of value.  This explains why we would reasonably expect problems of <a href="edge_instantiation.html">perverse instantiation</a> to pop up over and over again, the optimum of the revised concept moving to a new weird extreme each time the programmer tries to hammer down the next <a href="missing_weird.html">weird alternative</a> the AI comes up with.</p>
<p>In other words:  There's a large amount of <a href="Kolmogorov_complexity.html">algorithmic information</a> or many independent <a href="reflective_degree_of_freedom.html">reflectively consistent degrees of freedom</a> in the correct answer, the plans we <em>want</em> the AI to come up with, but we've only given the AI relatively simple concepts that can't <a href="safe_plan_identification.html">identify</a> those plans.</p>
<h1 id="analoguesinthehistoryofai">Analogues in the history of AI</h1>
<p>The result of trying to tackle overly <a href="agi.html">general</a> problems using AI algorithms too narrow for those general problems, usually appears in the form of <a href="http://lesswrong.com/lw/l9/artificial_addition/">an infinite number of special cases</a> with a new special case needing to be handled for every problem instance.  In the case of narrow AI algorithms tackling a general problem, this happens because the narrow algorithm, being narrow, is not capable of capturing the deep structure of the general problem and its solution.</p>
<p>Suppose that burglars, and also earthquakes, can cause burglar alarms to go off.  Today we can represent this kind of scenario using a Bayesian network or causal model which will <em>compactly</em> yield probabilistic inferences along the lines of, "If the burglar alarm goes off, that probably indicates there's a burglar, unless you learn there was an earthquake, in which case there's probably not a burglar" and "If there's an earthquake, the burglar alarm probably goes off."</p>
<p>During the era where everything in AI was being represented by first-order logic and nobody knew about causal models, [ people devised increasingly intricate "nonmonotonic logics"] to try to represent inference rules like (simultaneously) $~$alarm \rightarrow burglar, \ earthquake \rightarrow alarm,$~$ and $~$(alarm \wedge earthquake) \rightarrow \neg burglar.$~$  But first-order logic wasn't naturally a good surface fit to the set of inferences needed, and the AI programmers didn't know how to compactly capture the structure that causal models capture.  So the "nonmonotonic logic" approach proliferated an endless nightmare of special cases.</p>
<p>Cognitive problems like "modeling causal phenomena" or "being good at math" (aka understanding which mathematical premises imply which mathematical conclusions) might be <em>general</em> enough to defeat modern narrow-AI algorithms.  But these domains still seem like they should have something like a central core, leading us to expect [correlated_covereage correlated coverage] of the domain in <a href="advanced_agent.html">sufficiently advanced</a> agents.  You can't conclude that because a system is very good at solving arithmetic problems, it will be good at proving Fermat's Last Theorem.  But if a system is smart enough to independently prove Fermat's Last Theorem <em>and</em> the Poincare Conjecture <em>and</em> the independence of the Axiom of Choice in Zermelo-Frankel set theory, it can probably also - without further handholding - figure out Godel's Theorem.  You don't need to <em>go on</em> programming in one special case after another of mathematical competency.  The fact that humans could figure out all these different areas, without needing to be independently reprogrammed for each one by natural selection, says that there's something like a central tendency underlying competency in all these areas.</p>
<p>In the case of <a href="complexity_of_value.html">complexity of value</a>, the thesis is that there are many independent <a href="reflective_degree_of_freedom.html">reflectively consistent degrees of freedom</a> in our <a href="intended_goal.html">intended</a> specification of what's <a href="value_alignment_value.html">good, bad, or best</a>.  Getting one degree of freedom aligned with our intended result doesn't mean that other degrees of freedom need to align with our intended result.  So trying to "patch" the first simple specification that doesn't work, is likely to result in a different specification that doesn't work.</p>
<p>When we try to use a narrow AI algorithm to attack a problem which has a central tendency <em>requiring general intelligence to capture,</em> or at any rate requiring some new structure that the narrow AI algorithm can't handle, we're effectively asking the narrow AI algorithm to learn something that has no simple structure <em>relative to</em> that algorithm.  This is why early AI researchers' experience with "lack of common sense" <em>that you can't patch with special cases</em> may be <a href="foreseeable_difficulties.html">foreseeably</a> indicative of how frustrating it would be, in practice, to repeatedly try to "patch" a kind of difficulty that we may foreseeably need to confront in aligning AI.</p>
<p>That is:  Whenever it feels to a human like you want to yell at the AI for its lack of "common sense", you're probably looking at a domain where trying to patch that particular AI answer is just going to lead into another answer that lacks "common sense".  Previously in AI history, this happened because real-world problems had no simple central learnable solution relative to the narrow AI algorithm.  In value alignment, something similar could happen because of the <a href="complexity_of_value.html">complexity of our value function</a>, whose evaluations <em>also</em> <a href="underestimate_value_complexity_perceputal_property.html">feel to a human</a> like "common sense".</p>
<h1 id="relevancetoalignmenttheory">Relevance to alignment theory</h1>
<p>Patch resistance, and its sister issue of lack of <a href="correlated_coverage.html">correlated coverage</a>, is a central reason why aligning advanced agents could be way harder, way more dangerous, and way more likely to actually kill everyone in practice, compared to optimistic scenarios.  It's a primary reason to worry, "Uh, what if <em>aligning</em> AI is actually way harder than it might look to some people, the way that <em>building AGI in the first place</em> turned out not to be something you could do in two months over the summer?"</p>
<p>It's also a reason to worry about <a href="context_disaster.html">context disasters</a> revolving around capability gains:  Anything you had to patch-until-it-worked at AI capability level $~$k$~$ is probably going to break <em>hard</em> at capability $~$l \gg k.$~$  This is doubly catastrophic in practice if the pressures to "just get the thing running today" are immense.</p>
<p>To the extent that we can see the central project of AI alignment as revolving around finding a set of alignment ideas that <em>do</em> have simple central tendencies and <em>are</em> specifiable or learnable which together add up to a safe but powerful AI - that is, finding domains with correlated coverage that add up to a safe AI that can do something pivotal - we could see the central project of AI alignment as finding a collectively good-enough set of safety-things we can do <em>without</em> endless patching.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><p>This is a more general pattern in theoretical research. When you first start to attack a hard problem you often notice many promising lines of attack. Somehow in every line of attack, there will be at least (and often exactly) one thing that doesn't quite work out. Terence Tao has described this as feeling like "enemy movements" or something like this (though I can't find the quote). It is generally not possible to cross such gaps until you actually understand them. Once you do, instead of looking for a path from premises to conclusions you look for any gap in the chasm that seperates them. Once you've found the gap, it's often easy to go from premises to the gap and then from the gap to your conclusions.</p></p></div></section><footer><p class="all-creators"><h2>All Creators</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexeiAndreev.html">Alexei Andreev</a>,
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a>,
 <a class="page-link" href="../page/EricRogstad.html">Eric Rogstad</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/AndrewMcKnight.html">Andrew McKnight</a>,
 <a class="page-link" href="../page/AnnaSalamon.html">Anna Salamon</a>,
 <a class="page-link" href="../page/EricRogstad.html">Eric Rogstad</a>,
 <a class="page-link" href="../page/NunoFernandes.html">Nuno Fernandes</a></span></p><p class="related"><h2>Related</h2><ul class="page-list"><li><a class="page-link" href="../page/edge_instantiation.html">Edge instantiation</a> <q>When you ask the AI to make people happy, and it tiles the universe with the smallest objects that can be happy.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/low_impact.html">Low impact</a> <q>The open problem of having an AI carry out tasks in ways that cause minimum side effects and change as little of the rest of the universe as possible.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/nearest_unblocked.html">Nearest unblocked strategy</a> <q>If you patch an agent's preference framework to avoid an undesirable solution, what can you expect to happen?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/4v4.html">4v4</a></li></ul></p><p class="children"><h2>Children</h2><ul class="page-tree"><li><a class="page-link" href="../page/unforeseen_maximum.html">Unforeseen maximum</a> <q>When you tell AI to produce world peace and it kills everyone.  (Okay, some SF writers saw that one coming.)</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a><ul class="page-tree"><li><a class="page-link" href="../page/missing_weird.html">Missing the weird alternative</a> <q>People might systematically overlook &quot;make tiny molecular smileyfaces&quot; as a way of &quot;producing smiles&quot;, because our brains automatically search for high-utility-to-us ways of &quot;producing smiles&quot;.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></li></ul></p></footer></body></html>