<!DOCTYPE html><html><head><meta charset="utf-8"><title>Optimization and goals</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="../MathJax-2.7.5/MathJax.js"></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Optimization and goals</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/optimization_goals.json.html">optimization_goals.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/optimization_goals">https://arbital.com/p/optimization_goals</a></p><p class="creator">by
 <a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a> Feb 1 2016 
updated
 Mar 4 2016</p></div><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Optimization and goals</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="paul_ai_control.html">Paul Christiano's AI control blog</a></li><li>…</li></ul></nav></nav></header><hr><main><p>If we want to write a program that&nbsp;<em>doesn’t</em>&nbsp;pursue a goal, we can have two kinds of trouble:</p>
<ol>
<li>We might need to explicitly introduce goal-directed behavior into our program, because it’s the easiest way to do what we want to do.</li>
<li>We might try to write a program that doesn’t pursue a goal, and fail.</li>
</ol>
<p>Issue [2] sounds pretty strange—it’s not the kind of bug most software has. But when you are programming with gradient descent, strange things can happen.</p>
<p>In this post I illustrate issue [2] by considering a possible design for an <a href="approval_directed_agents.html">approval-directed</a>&nbsp;system, intended to take individual actions the user would approve of without considering their long-term consequences.</p>
<h3 id="thearchitecture">The architecture</h3>
<p>Our agent takes as input a sequence of observations&nbsp;<em>x[t]</em> ∈ {0, 1} and outputs a sequence of actions&nbsp;<em>a[t]</em> ∈ {0, 1}.</p>
<p>The main ingredient is a pair of functions A&nbsp;: ℜⁿ →&nbsp;{0, 1}&nbsp;, S: ℜⁿ&nbsp;× {0, 1} → ℜⁿ.</p>
<p>To run the <em>agent:</em></p>
<ul>
<li>We initialize&nbsp;s[0] = 0ⁿ.</li>
<li>Define&nbsp;a[t] = A(<em>s</em> [<em>t</em> ]<em>)</em></li>
<li>Define&nbsp;s[t+1] =&nbsp;S (s[t], x[t])</li>
</ul>
<p>For concreteness you might imagine that A and S are feed-forward neural networks, so that the entire system is a typical recurrent neural network. I’m going to imagine performance well beyond anything we can currently get out of a recurrent neural network.</p>
<p>Our training data consists of some sequence of observations&nbsp;<em>x</em>[_t_] and reward functions&nbsp;r[t]&nbsp;: {<em>0, 1</em>} →&nbsp;<em>ℜ</em>.&nbsp;We train A and S to maximize Σ&nbsp;<em>r[t]</em>(<em>a</em>[_t_]). We’ll define&nbsp;<em>r</em> <em>[T]</em> <em>(a)</em> to be how much we approve of taking&nbsp;<em>a</em>&nbsp;in the context of step&nbsp;<em>t</em>.</p>
<p>To gather training data, we use the current version of A and S to control a robot, we define&nbsp;<em>x</em>[_t_] as the robot’s sensor reading at step&nbsp;<em>t</em>, and we manually provide the reward functions&nbsp;<em>r[t]</em>&nbsp;as look-up tables.</p>
<p>We hope that if we use A and S to control a robot, the resulting system chooses each action to maximize our approval&nbsp;<em>of that action</em>. (This might seem like a crazy design, but for now let’s just ask whether the resulting system will exhibit goal-directed behavior.)</p>
<p>The state&nbsp;<em>s</em>&nbsp;is important for most applications. We’d like our agent to make decisions based on everything it knows, not based only on what it currently observes. By optimizing S to store useful information, we allow the system to remember information across time steps and aggregate many observations to make informed judgments.</p>
<h3 id="whathappens">What happens?</h3>
<p>This system looks like it shouldn’t form any long-term plans; each action should be selected greedily, without concern for its consequences. The separation of A and S makes this perfectly explicit: A is essentially a classifier, which labels each state&nbsp;<em>s</em>&nbsp;with the most-approved action&nbsp;<em>a</em>&nbsp;∈ {0, 1}. There isn’t any room for A to consider long-term consequences.</p>
<p>How would this system work, if it worked well? What would the learned function S look like?</p>
<p>Here are some possible properties, which seem like the “right” way to optimize the reward function. That is, if you optimized well enough, over a large enough space of functions, I would expect you to observe these behaviors:</p>
<ol>
<li>The state&nbsp;<em>s</em>&nbsp;encodes beliefs about the agent’s environment. (Assuming that our approval, and hence the reward function&nbsp;<em>r</em>, is mostly determined by the environment.)</li>
<li>The function S updates the agent’s current beliefs based on the observation&nbsp;<em>x</em>.</li>
<li><em>s</em>&nbsp;selectively remembers facts that are likely to be useful, because it doesn’t have enough space to remember everything in detail. It also stores the results of cached computations—the function A doesn’t have time to do much computation, so if complicated computations are useful, the agent must carry them out over many steps and remember the results. (For example, if the agent saw a puzzle written on a sheet of paper, the agent might compute and store its answer to use later.)</li>
<li>S uses non-trivial rules to decide what to remember or compute. All of these decisions are at least implicitly optimized to make efficient use of limited resources. These choices depend on what situations will arise in the future, and so S should use its full predictive ability to make them. For example, when deciding whether to forget X or forget Y, S might predict what reward it will receive in each case and choose the better option (this computation could use cached intermediate results and predictions, implicitly taking place over many steps).&nbsp;<strong>In general, S updates&nbsp;<em>s</em> rationally to maximize its expected future reward.</strong></li>
<li>The agent is able to reason about the relationship between its own beliefs and the world. For example, it might realize that a particular fact will be repeated later, and so not bother remembering it. This clearly requires making a prediction about what it will observe in the future. But it’s also based on a prediction about how S will update&nbsp;<em>s</em>&nbsp;in response to that observation, and about how A will respond to different values of&nbsp;<em>s</em>.</li>
</ol>
<p>These all sound like good things. Each of them leads the agent to perform better when deployed. We could imagine accomplishing the same goals with simple heuristics, but as we get enough training data the heuristics should converge to rational behavior.</p>
<p>But these properties, and especially property 4, may have some counterintuitive consequences.</p>
<p>We can easily see the shadow of plans: when the agent chooses the state&nbsp;<em>s</em>, it won’t greedily maximize the next round’s performance (and we wouldn’t want it to, since this would mean promptly forgetting everything that isn’t immediately relevant). Instead, it will choose a state&nbsp;<em>s</em>&nbsp;that is useful for long-term performance. And to do that, it will think about long-term consequences.</p>
<h3 id="whatgoeswrong">What goes wrong?</h3>
<p>When the agent anticipates the consequences of choosing different values of s[t], it sees that different choices lead to different sequences of states, hence different sequences of predictions, hence different rewards. During training the agent&nbsp;<em>doesn’t</em>&nbsp;expect different states to lead to different events in the world, because it was trained on the fixed actions taken by previous versions of A,S.</p>
<p>But when the system is actually deployed, changing&nbsp;<em>s</em>&nbsp;will also change what action is actually taken. If the system is a good general purpose learner, it will notice this relationship (along with many other patterns that happen to appear while the system is deployed but didn’t appear in any training episode.)</p>
<p>For example, if the agent forgets where an item is and is unable to find it when asked, the agent is likely to be reminded where to look. In general, the agent should notice patterns like “If I forget X, I am more likely to be reminded of X in the future.” Once the agent notices this pattern, the agent should act on it—after all, the agent is already acting on many similar patterns.</p>
<p>If the agent rationally chooses&nbsp;<em>s</em>&nbsp;to maximize future rewards, it might take more extreme measures. For example, it might reason “If I choose a state&nbsp;s which incorrectly `remembers’ that the user asked me to write down X, then I will write down X. If I write down X, I will remember X in the future. This will lead to low reward in the next few rounds, since the user&nbsp;didn’t&nbsp;ask me to write down X. But this is more than offset by the high future reward from remembering X on many different occasions.”</p>
<p>In an even more extreme case, the agent might reason “If I choose a state&nbsp;swhich incorrectly `remembers’ that the user asked me to implement another AI whose goal is maximizing my future reward, I will achieve a high future reward. I will get an approval of 0 while I am implementing the new AI, but this will be more than offset by my high reward thereafter.”</p>
<p>This example is of course facetious, but hopefully it illustrates the point. If we actually want the robot to maximize its total approval, then we should be happy with this result. But now we are right back in the goal-directed case.</p>
<h3 id="upshot">Upshot</h3>
<p>If you trained a sufficiently weak S, it would not display goals nor exhibit human-level reasoning. If you trained a sufficiently powerful S, it might display goals and would definitely be superhuman. Somewhere in between you get human-level performance, and somewhere in between you probably get goal-directed behavior.</p>
<p>It’s not clear whether goal-directed behavior emerges before or after human-level performance. But I am wary of systems that only behave as intended in a sweet spot between being “good enough” and “too good,” or which depend on optimistic assumptions. It would be more satisfying to design systems that perform robustly regardless of how smart they are.</p>
<p>I suspect that similar problems will arise frequently if we train very intelligent but goal-free systems.</p>
<p>One response is to give up on designing intelligent systems without goals—to conclude that in order to build systems that work robustly, we should conservatively assume that they have goals. This is probably somewhat premature.</p>
<p>Another response is to find a better training criterion, which doesn’t involve maximizing a sum of future rewards. But it’s not clear how to do this while also training the system to build a useful representation, since the usefulness of a representation is determined by long-term performance. We could train F to create a state&nbsp;<em>s</em>&nbsp;which is useful on the very next time step (i.e. we could propagate gradients from s[_n+1_] to the parameters of S, but not back to s[n]), and hope that the resulting update rule happens to be appropriate over longer time scales. But this seems to rest on a pretty optimistic assumption.</p>
<p>A third response is to also update the state&nbsp;<em>s</em>&nbsp;in the most-approved-of way. But this forces the human engineers to figure out how the system should store its knowledge, which may be a serious problem (though it&nbsp;<a href="approval_directed_bootstrapping.html">might</a>&nbsp;be manageable).</p>
<p>A final possible response is to “cross that bridge when we come to it.” I would like to understand AI safety further in advance, and understanding the inevitability of goal-directed behavior is a natural step. So although this option is tempting, I am hesitant to accept it. Our theoretical understanding is also so weak that I feel we can go somewhat further before we run into a hard requirement for empirical feedback. I’ll find this option more tempting once we are going in circles rather than making steady headway.</p></main><hr><footer><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexRay.html">Alex Ray</a></span></p></footer></body></html>