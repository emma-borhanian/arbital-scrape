<!DOCTYPE html><html><head><meta charset="utf-8"><title>Note on 1x1 Convolutions</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="../MathJax-2.7.5/MathJax.js"></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Note on 1x1 Convolutions</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/8s1.json.html">8s1.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/8s1">https://arbital.com/p/8s1</a></p><p class="creator">by
 <a class="page-link" href="../page/AltoClef.html">Alto Clef</a> Oct 27 2017</p></div><p class="clickbait">what's the purpose?</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Note on 1x1 Convolutions</li></ul></nav></nav></header><hr><main><h2 id="whatdoesitdo">What does it do?</h2>
<p>This is pretty straight forward, just like normal convolution operation, it converts a piece of data structured <code>[channels, height, width]</code> to <code>[kernal\_numbers, same\_height, same\_width]</code>, using a set of learn-able parameters in the size of <code>[kernel\_number, channel\_number, weight\_for\_this\_channel]</code>. This operation is usually just a meaningless scaling by a constant unless it is performed across channels, which is usually called a cascade cross channel pooling layer. </p>
<h2 id="whatsthepurpose">What's the purpose?</h2>
<p>Along all materials read, it seems like this operation is widely used on the following purposes:</p>
<h3 id="dimensionaugmentationreduction">Dimension augmentation/reduction.</h3>
<p>This operation is capable of mapping an input of any channel to an output of any channel while preserving the original size of the picture. Do be aware that such operation, especially in dimensionality augmentations, uses large amount of extra parameters, making the network possible more prone to overfitting.</p>
<h3 id="rescalingthelastlayer">Rescaling the last layer.</h3>
<p>In the above it's mentioned that 1x1 convolution could serve as a plain scale of a whole channel, which is usually unnecessary. However, if such need exist, it could be met though this operation.</p>
<h3 id="increasingnonlinearity">Increasing non-linearity.</h3>
<p>The fact that it involves a non-linear mapping without drastically altering the input, the non-linearity of the network is increased without using plain fully-connected layers which destroys the relationship between nearby pixels. At the same time, the original size of the input could be preserved.</p>
<h3 id="thenetworkinnetworkninstructure">The (Network in Network)NIN Structure</h3>
<p>This concept first appeared to me while reading a research paper called <a href="https://arxiv.org/pdf/1312.4400v3.pdf">network in network</a>, which seems to be another powerful modification made on CNNs. One of the key aspect this paper adapted is using a multilayer perceptron model to replace the traditional convolution kernel. </p>
<p>As I wonder how could this model be implemented using higher level api of popular machine learning libraries without modifying the lower level codes, the paper actually stated that such operation of sliding a mini-MLP over a picture across the previous channels is equivalent to cross channel convolution with 1x1 kernels, where a few new 1x1 convolutional layer(CCCP) is appended to a normal convolutional layer to reach the goal.</p>
<p>The fact that this CCCP operation appending to a normal convolution layers will make a equivalent MLP serves as a sliding convolution kernel, is hard to imagine to be true. It creates confusion in my understanding and it is not until I unroll the whole process so it could be under stood.</p>
<p>Rather than 2d convolution, using 1d convolution makes things more straight forward while the same rule applies to arbitrary dimensions of convolution.</p>
<p>Suppose we have an 1d input with 2 channels:
<br>
<img src="https://github.com/D0048/makeyourownneuralnetwork/blob/master/img_bed/1d_input.png?raw=true" alt="" />
<br>
And we perform a normal convolution with one kernel of 2.
<br>
<img src="https://github.com/D0048/makeyourownneuralnetwork/blob/master/img_bed/1d_input_conv2.png?raw=true" alt="" />
<br>
After appending a 1x1(in 1d convolution, just 1) convolution layer with <strong>two</strong> kernels, it looks like:
<br>
<img src="https://github.com/D0048/makeyourownneuralnetwork/blob/master/img_bed/1d_input_conv2_conv1.png?raw=true" alt="" />
<br>
And another 1x1 layer with <strong>two</strong> kernels added:
<br>
<img src="https://github.com/D0048/makeyourownneuralnetwork/blob/master/img_bed/1d_input_conv2_conv1_conv1.png?raw=true" alt="" />
<br>
It's not hard to see, that this structure is indeed a sliding MLP layer with the input size of the convolution size of the layer appended to, the depth of the number of 1x1 layers appended and the hidden unit numbers of the product of all kernel numbers in the hidden unit, the input numbers and the last layer.</p>
<h3 id="theinceptionmodule">The Inception module</h3>
<p>The <a href="https://hacktilldawn.com/2016/09/25/inception-modules-explained-and-implemented/">inception module</a> is first used in the googlenet architecture, and proved to be really useful. 
<img src="https://raw.githubusercontent.com/iamaaditya/iamaaditya.github.io/master/images/inception_1x1.png" alt="" />
<center>picture retrieved from this <a href="https://wiki.tum.de/display/lfdv/Layers+of+a+Convolutional+Neural+Network">website</a></center></p>
<p>What this module does is really just adjoining all the output of different size of convolution/pooling together and let the network to choose which to use itself. The pro of this method is that the network is made more resistant to shift in sizes of the target, and the manually adjusting size of the kernels is no longer required--we got most of the possible sizes needed all here.</p>
<p>As a result, the 1x1 convolution naturally became one of the choices.</p>
<h2 id="ideasforfutureresearch">Ideas for Future Research</h2>
<p>As I read, neurons that fired together creates a relationship between each other and every one of them got easier to fire next time given the condition that the related neurons are fired.</p>
<p>I am thinking that neurons in regular DNNs does not have any knowledge of the state of other neurons in the same layer, thus maybe it would be possible to create such a relation, to somehow create <strong>"logic"</strong> for networks?</p>
<p>To do so, maybe we need another set of weights in each neuron used to scale the states of other neurons in the same layer and add to the output, somehow like this:
$$~$
\vec{y_{n}}=(\mathbf{W_n}^T \times  \vec{y_{n-1}} + \vec{b_n})+\mathbf{W_{new}}^T (\mathbf{W_n}^T \times  \vec{y_{n-1}} + \vec{b_n})
$~$$
<center><strong>If the formula is not displayed correctly, please allow unsecure(HTTP) cross site scripts in your browser.</strong></center>
The new weight matrix for the new output will be an <code>n*n</code> matrix considering <code>n</code> as the size of the output.</p>
<p>The detailed implementation is to be researched.</p>
<p>Edit: Okayâ€¦ This seems to be just an really stupid way of adding an extra layer, and won't really make any difference from just adding one at all.(2017/10/27)</p>
<p>References:<br>
<a href="http://blog.csdn.net/yiliang_/article/details/60468655">http://blog.csdn.net/yiliang_/article/details/60468655</a>
<a href="http://blog.csdn.net/mounty_fsc/article/details/51746111">http://blog.csdn.net/mounty_fsc/article/details/51746111</a>
<a href="http://jntsai.blogspot.com/2015/03/paper-summary-network-in-network-deep.html">http://jntsai.blogspot.com/2015/03/paper-summary-network-in-network-deep.html</a>
<a href="https://www.zhihu.com/question/64098749">https://www.zhihu.com/question/64098749</a></p></main><hr><footer></footer></body></html>