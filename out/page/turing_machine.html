<!DOCTYPE html><html><head><meta charset="utf-8"><title>Turing machine</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="../MathJax-2.7.5/MathJax.js"></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Turing machine</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/turing_machine.json.html">turing_machine.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/turing_machine">https://arbital.com/p/turing_machine</a></p><p class="creator">by
 <a class="page-link" href="../page/EricLeese.html">Eric Leese</a> Jul 31 2016 
updated
 Oct 3 2016</p></div><p class="clickbait">A Turing Machine is a simple mathematical model of computation that is powerful enough to describe any computation a computer can do.</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Turing machine</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="math.html">Mathematics</a></li><li>…</li></ul></nav></nav></header><hr><main><p>A Turing Machine is a simple mathematical model of [-computation] that is powerful enough to describe any computation a computer can do.</p>
<p>Imagine a robot, in front of a little whiteboard, with infinitely many whiteboards to both sides, finitely many of which have a symbol written on them. The robot can erase the contents of a whiteboard and replace it with some other symbol, and it can move over to the next whiteboard on the left or right, or shut down. This is all the robot can do. The robot's actions are determined by only two things: the symbol on the whiteboard it just saw, and its internal state. The output of this process is defined to be "whatever is written on the string of whiteboards when the robot has shut down".</p>
<p>This is equivalent to a Turing Machine (with the robot replaced by a machine head and the infinite line of whiteboards replaced by an infinite tape subdivided into cells). The <em>halting problem</em> (which [halting_problem_is_uncomputable is unsolvable] in general) asks whether the robot will eventually shut down at some point.</p>
<p>So, a Turing Machine can be specified with the following information: </p>
<ul>
<li>A finite set of symbols the robot can write (one of which is the null symbol, an empty board).</li>
<li>A finite set of states the robot can be in (at least one of which causes the robot to shut down).</li>
<li>A starting state for the robot.</li>
<li>Starting symbols on finitely many of the boards (whiteboard location and symbol type data).</li>
<li>A transition function for the robot, which takes a symbol/state pair as input, and has a $~$(\text{symbol},\text{state},\text{move left or right})$~$ triple as output. For example, ine such transition might be represented as <code>if symbol is 7 and state is FQUF, then (erase and write 4, set state to ZEXA, move left)</code>.</li>
</ul>
<p>Surprisingly enough, other proposed models of computation have all been shown to be weaker than, or equivalent to, Turing Machines! With infinite memory space, and sufficiently intricate sets of symbols and states, the robot and whiteboard (or machine head and memory tape) system can compute anything at all that is computable in principle!
This fact is known as the Church-Turing thesis; it's very widely believed to be true, and certainly no-one has ever found any hint of a counterexample, but it's not "proved" in any meaningful sense.</p>
<h1 id="variantsofturingmachines">Variants of Turing machines</h1>
<p><em>Multi-tape Turing Machines</em> would be equivalent to having several robots in infinite whiteboard hallways, except that the robots are networked together to all share the same state. An example state transition is as follows:</p>
<p><code>If symbol A is * and symbol B is 6 and symbol C is absent and state is VREJ, set state to IXXI, robot A writes ! and moves left, robot B writes 9 and moves left, robot C writes = and doesn't move.</code></p>
<p>These Multi-tape Machines can speed up some computations polynomially (so, for example, a problem which would normally take 1 million steps to solve may be solvable in a thousand steps, because of the square root speedup). Because these machines can only muster a polynomial speedup, and moving to a one-tape Turing Machine only incurs a polynomial slowdown, the computational <a href="polynomial_time_complexity_class.html">complexity class P</a> is unchanged across Turing Machines with different numbers of tapes.</p>
<p><em>Write-only Turing Machines</em> are Multi-tape Turing Machines where one of the tapes/hallways of whiteboards has its input ignored when determining the next state, written symbols and movements.
We can think of this situation as one where one particular robot is blind.</p>
<p><em>Read-only Turing Machines</em> are Multi-tape Turing Machines, and one of the tapes/hallways of whiteboards cannot be rewritten. The robot in there can only move around and observe, but it has not been given a pen or rubber so it can't write on or erase the boards.</p>
<p><em>Oracle Machines</em> (which are more powerful than Turing Machines, and don't exist in reality, though they are a very useful tool in computational complexity theory), are like a mult-tape machine with exactly two tapes: one tape is designated as the "oracle tape", and one tape as the "machine tape".
This time, one of the robot states is "INVOKING MAGIC ORACLE".
When that happens, the contents of the whiteboards in the machine hall (that is, the contents of the machine tape) are interpreted as the description of a problem, and then a correct solution to the problem magically appears on the string of whiteboards in the oracle hall (that is, on the oracle tape), completely erasing whatever was on the oracle hall whiteboards originally; and finally the oracle robot is moved to the first whiteboard of the answer.</p>
<p>Therefore the functionality of the oracle machine depends very strongly on what the oracle does! A given oracle machine might do one thing when the oracle does "compute the <a href="factorial.html">Factorial</a> of the number I was called with" than when it does "compute whether or not the number I was given is the [-description_number] of a halting Turing machine".</p>
<p>Oracle machines are like ordinary Turing machines, except we also give them the ability (in principle) to obtain instant correct answers to any particular problem. The problem we may instantly solve is fixed in advance, before we ever start running the machine.
With the right oracle, oracle machines can solve <em>any</em> problem, where Turing machines cannot (recalling that the halting problem can't be solved by Turing machines).
However, the price is that oracle machines don't exist: they require a magic oracle, and we don't have any of those in nature.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a></p><p><p>Maybe the alternate variants would be best on separate child pages, with links to them from this page?</p></p></div></section><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/c_class_meta_tag.html">C-Class</a></span></p><p class="all-creators"><h2>All Creators</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexAppel.html">Alex Appel</a>,
 <a class="page-link" href="../page/AlexeiAndreev.html">Alexei Andreev</a>,
 <a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a>,
 <a class="page-link" href="../page/EricLeese.html">Eric Leese</a>,
 <a class="page-link" href="../page/PatrickStevens.html">Patrick Stevens</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a></span></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/c_class_meta_tag.html">C-Class</a> <q>This page has substantial content, but may not thoroughly cover the topic, may not meet style and prose standards, or may not explain the concept in a way the target audience will reliably understand.</q> - <a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a></li></ul></p><p class="children"><h2>Children</h2><ul class="page-tree"><li><a class="page-link" href="../page/rice_theorem.html">Rice's Theorem</a> <q>Rice's Theorem tells us that if we want to determine pretty much anything about the behaviour of an arbitrary computer program, we can't in general do better than just running it.</q> - <a class="page-link" href="../page/PatrickStevens.html">Patrick Stevens</a><ul class="page-tree"><li><a class="page-link" href="../page/proof_of_rice_theorem.html">Proof of Rice's theorem</a> <q>A standalone proof of Rice's theorem, including one surprising lemma.</q> - <a class="page-link" href="../page/PatrickStevens.html">Patrick Stevens</a></li><li><a class="page-link" href="../page/6bf.html">Rice's Theorem: Intro (Math 1)</a> <q>You can't write a program that looks at another programs source code, and tells you whether it computes the Fibonacci sequence.</q> - <a class="page-link" href="../page/DylanHendrickson.html">Dylan Hendrickson</a></li><li><a class="page-link" href="../page/rice_and_halt.html">Rice's theorem and the Halting problem</a> <q>We will show that Rice's theorem and the the halting problem are equivalent.

#The Halting theorem i…</q> - <a class="page-link" href="../page/JaimeSevillaMolina.html">Jaime Sevilla Molina</a></li></ul></li><li><a class="page-link" href="../page/turing_machine_external_resources.html">Turing machine: External resources</a> <q>* [Wikipedia](https://en.wikipedia.org/wiki/Turing_machine)
* [Wolfram MathWorld](http://mathworld.w…</q> - <a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a></li></ul></p></footer></body></html>