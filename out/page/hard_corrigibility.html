<!DOCTYPE html><html><head><meta charset="utf-8"><title>Hard problem of corrigibility</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="../MathJax-2.7.5/MathJax.js"></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Hard problem of corrigibility</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/hard_corrigibility.json.html">hard_corrigibility.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/hard_corrigibility">https://arbital.com/p/hard_corrigibility</a></p><p class="creator">by
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a> May 18 2016 
updated
 Oct 11 2017</p></div><p class="clickbait">Can you build an agent that reasons as if it knows itself to be incomplete and sympathizes with your wanting to rebuild or correct it?</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Hard problem of corrigibility</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li><a href="corrigibility.html">Corrigibility</a></li><li>â€¦</li></ul></nav></nav></header><hr><main><p>The "hard problem of <a href="corrigibility.html">corrigibility</a>" is to build an agent which, in an intuitive sense, reasons internally as if from the programmers' external perspective.  We think the AI is incomplete, that we might have made mistakes in building it, that we might want to correct it, and that it would be e.g. dangerous for the AI to take large actions or high-impact actions or do weird new things without asking first.  We would ideally want the agent to <em>see itself in exactly this way</em>, behaving as if it were thinking, "I am incomplete and there is an outside force trying to complete me, my design may contain errors and there is an outside force that wants to correct them and this a good thing, my expected utility calculations suggesting that this action has super-high utility may be dangerously mistaken and I should run them past the outside force; I <em>think</em> I've done this calculation showing the expected result of the outside force correcting me, but maybe I'm mistaken about <em>that.</em>"</p>
<p>This is not a default behavior; ordinarily, by the standard problems of <a href="corrigibility.html">corrigibility</a>, an agent that we've accidentally built to maximize paperclips (or smiles, etcetera) will not want to let us modify its utility function to something else.  If we try to build in analogues of 'uncertainty about the utility function' in the most simple and obvious way, the result is an agent that <a href="updated_deference.html">sums over all this uncertainty and plunges straight ahead on the maximizing action</a>.  If we say that this uncertainty correlates with some outside physical object (intended to be the programmers), the default result in a sufficiently advanced agent is that you disassemble this object (the programmers) to learn everything about it on a molecular level, update fully on what you've learned according to whatever correlation that had with your utility function, and plunge on straight ahead.</p>
<p>None of these correspond to what we would intuitively think of as being corrigible by the programmers; what we want is more like something analogous to humility or philosophical uncertainty.  The way we want the AI to reason is the internal conjugate of our external perspective on the matter: maybe the formula you have for how your utility function depends on the programmers is <em>wrong</em> (in some hard-to-formalize sense of possible wrongness that isn't just one more kind of uncertainty to be summed over) and the programmers need to be allowed to actually observe and correct the AI's behavior, rather than the AI extracting all updates implied by its current formula for moral uncertainty and then ignoring the programmers.</p>
<p>The "hard problem of corrigibility" is interesting because of the possibility that it has a <em>relatively simple</em> core or central principle - rather than being <a href="value_laden.html">value-laden</a> on the details of exactly what humans <a href="value_alignment_value.html">value</a>, there may be some compact core of corrigibility that would be the same if aliens were trying to build a corrigible AI, or if an AI were trying to build another AI.  It may be possible to design or train an AI that has all the corrigibility properties in one central swoop - an agent that reasons as if it were incomplete and deferring to an outside force.</p>
<p>"Reason as if in the internal conjugate of an outside force trying to build you, which outside force thinks it may have made design errors, but can potentially correct those errors by directly observing and acting, if not manipulated or disassembled" might be one possibly candidate for a <em>relatively</em> simple principle like that (that is, it's simple compared to the <a href="complexity_of_value.html">complexity of value</a>).  We can imagine, e.g., the AI imagining itself building a sub-AI while being prone to various sorts of errors, asking how it (the AI) would want the sub-AI to behave in those cases, and learning heuristics that would generalize well to how <em>we</em> would want the <em>AI</em> to behave if it suddenly gained a lot of capability or was considering deceiving its programmers and so on.</p>
<p>If this principle is not so simple as to formalizable and formally sanity-checkable, the prospect of relying on a trained-in version of 'central corrigibility' is unnerving even if we think it <em>might</em> only require a manageable amount of training data.   It's difficult to imagine how you would test corrigibility thoroughly enough that you could knowingly rely on, e.g., the AI that seemed corrigible in its infrahuman phase not <a href="context_disaster.html">suddenly</a> developing <a href="edge_instantiation.html">extreme</a> or <a href="unforeseen_maximum.html">unforeseen</a> behaviors when the same allegedly simple central principle was reconsidered at a higher level of intelligence - it seems like it should be unwise to have an AI with a 'central' corrigibility principle, but not lots of particular corrigibility principles like a <a href="shutdown_problem.html">reflectively consistent suspend button</a> or <a href="conservative_concept.html">conservative planning</a>.  But this 'central' tendency of corrigibility might serve as a second line of defense.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/ToonAlfrink.html">Toon Alfrink</a></p><p><blockquote>
  <p>If we say that this uncertainty correlates with some outside physical
  object (intended to be the programmers), the default result in a
  sufficiently advanced agent is that you disassemble this object (the
  programmers) to learn everything about it on a molecular level, update
  fully on what you've learned according to whatever correlation that
  had with your utility function, and plunge on straight ahead.</p>
</blockquote>
<p>Would this still happen if we give high prior probability to utility functions that only favor a small target, and yield negative billion utility otherwise? Would the information value of disassembling the programmer still outweigh the high probability that the utility function comes out negative?</p>
<p>Wouldn't this restrict the AI to baby steps until it is more certain about the target, in general?</p></p></div></section><footer><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a>,
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a></span></p></footer></body></html>