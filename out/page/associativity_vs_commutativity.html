<!DOCTYPE html><html><head><meta charset="utf-8"><title>Associativity vs commutativity</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="../MathJax-2.7.5/MathJax.js"></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Associativity vs commutativity</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/associativity_vs_commutativity.json.html">associativity_vs_commutativity.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/associativity_vs_commutativity">https://arbital.com/p/associativity_vs_commutativity</a></p><p class="creator">by
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a> May 15 2016</p></div><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Associativity vs commutativity</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="math.html">Mathematics</a></li><li><a href="associative_operation.html">Associative operation</a></li><li>…</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="math.html">Mathematics</a></li><li><a href="commutative_operation.html">Commutative operation</a></li><li>…</li></ul></nav></nav></header><hr><main><p><a href="associative_operation.html">Associativity</a> and <a href="commutative_operation.html">commutativity</a> are often confused, because they are both constraints on how a <a href="function.html">function</a> treats its inputs, and they are both constraints saying "these two paths for calculating the output must yield the same answer." The difference is that commutativity says "this function shouldn't care what order its own arguments come in," while associativity says "different ways of using this function multiple times should yield the same results."</p>
<p>Commutativity is about an invariance in <em>one</em> call to the function: If you run the function once with inputs $~$x$~$ and $~$y,$~$ you'll get the same result as if you run it once with inputs $~$y$~$ and $~$x.$~$</p>
<p>Associativity is about an invariance in <em>multiple</em> calls to the function: If you combine four elements using three function calls in the order $~$a \cdot (b \cdot (c \cdot d)),$~$ you'll get the same answer as if you use the three function calls in the order $~$((a \cdot b) \cdot c) \cdot d.$~$</p>
<p>Commutativity means you can swap the order of the elements. Associativity means you can drop parenthesis when combining multiple elements in a row.</p>
<p>If an operator $~$\cdot$~$ is both commutative and associative, then when you're combining multiple elements in a row, you're welcome to combine them in <em>any</em> order: For example, when adding $~$3 + 2 + (-7) + 5 + (-2) + (-3) + 7,$~$ we can re-arrange the list to get $~$3 - 3 + 2 - 2 + 7 - 7 + 5 = 5,$~$ which makes calculation easy. To see that this is the case, note that the result won't change if we swap any two adjacent elements, because associativity means that we can pick any two adjacent elements to start with and commutativity says that the order of those elements doesn't matter. Then, we can re-arrange the list however we like using a series of two-element swaps.
[fixme: Perhaps conditionalize this parenthetical on something like "cares about abstract algebra" or "wants tidbits they don't understand to point them towards cool things" or something.]
(This is why <a href="abelian_group.html">commutative groups</a> are especially easy to work with.)</p>
<h2 id="examples">Examples</h2>
<p>Addition is both commutative and associative (same with multiplication). Subtraction is neither commutative nor associative (same with division).</p>
<p><a href="string_concatenation.html">String concatenation</a> is associative but not commutative: If you're sticking a bunch of <a href="text_string.html">strings</a> together end on end, then it doesn't matter which adjacent pairs you combine first, but <code>"onetwo"</code> is a very different string than <code>"twoone"</code>.</p>
<p>Rock-paper-scissors is commutative but not associative. The winner of "rock v scissors" is rock, and the winner of "scissors v rock" is rock, and so on; but if you have a bunch of people in a line make rock, paper, or scissors signs, then who is the winer depends on which end of the line you start from: If the line has three people, and they throw [rock, paper, scissors], then the winner will be whoever threw scissors if you start from the left (by finding the winner between rock and paper,  and then playing that against scissors) or rock if you start on the right (by finding the winner between paper and scissors, and then playing that against rock).</p>
<p>The function <code>pair</code> which puts its inputs into a pair (such that <code>pair(x, y) = (x, y)</code>) is neither commutative nor associative: <code>(x, y)</code> does not equal <code>(y, x)</code>, and <code>(x, (y, z))</code> does not equal <code>((x, y), z)</code>. The output of <code>pair</code> preserves the ordering and structure of all its inputs, and leaves a trace that allows one to distinguish which inputs it was called on when. Both commutativity and associativity require the function to be "forgetful" about some aspect of how it was called: Commutative functions need to be insensitive to the ordering of their arguments; associative functions need to leave no trace that can be used to figure out which inputs were combined in what order. Thus, any function that bakes a lot of history about what it was called with into the output is unlikely to be commutative or associative.</p>
<h2 id="mnemonics">Mnemonics</h2>
<p>If it helps you to remember which is which, consider these two mnemonics:</p>
<p>For "commutativity," imagine that the two parameters to the function each live on one side of town and work on the other side. Each morning, they pass each other on their morning <em>commute,</em> as they swap places.</p>
<p>For "associativity," imagine a bunch of <em>associates</em> all standing in a line, ranked according to their hierarchy in a law firm. Any two adjacent people are willing to converse with each other, although people on one end of the line might not be willing to associate with people on the other end.</p></main><hr><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/needs_clickbait_meta_tag.html">Needs clickbait</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a>,
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a>,
 <a class="page-link" href="../page/ZackMDavis.html">Zack M. Davis</a></span></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/needs_clickbait_meta_tag.html">Needs clickbait</a> <q>This page does not have clickbait (a short teaser for the page displayed on various lists). Feel free to add it!</q> - <a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a></li></ul></p></footer></body></html>