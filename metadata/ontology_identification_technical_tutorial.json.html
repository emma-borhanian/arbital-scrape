<!DOCTYPE html><html><head><meta charset="utf-8"><title>Ontology identification problem: Technical tutorial</title><link rel="stylesheet" type="text/css" href="../common.css"></head><body><pre style="white-space:pre-wrap">{
  localUrl: '<a href="../page/ontology_identification_technical_tutorial.html">../page/ontology_identification_technical_tutorial.html</a>',
  arbitalUrl: '<a href="https://arbital.com/p/ontology_identification_technical_tutorial">https://arbital.com/p/ontology_identification_technical_tutorial</a>',
  rawJsonUrl: '<a href="../raw/6b.json">../raw/6b.json</a>',
  likeableId: '<a href="2366.json.html">2366</a>',
  likeableType: 'page',
  myLikeValue: '0',
  likeCount: '3',
  dislikeCount: '0',
  likeScore: '3',
  individualLikes: [
    '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
    '<a href="AdeleLopez.json.html">AdeleLopez</a>',
    '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>'
  ],
  pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
  edit: '11',
  editSummary: '',
  prevEdit: '10',
  currentEdit: '11',
  wasPublished: 'true',
  type: 'wiki',
  title: 'Ontology identification problem: Technical tutorial',
  clickbait: 'Technical tutorial for ontology identification problem.',
  textLength: '33351',
  alias: 'ontology_identification_technical_tutorial',
  externalUrl: '',
  sortChildrenBy: 'likes',
  hasVote: 'false',
  voteType: '',
  votesAnonymous: 'false',
  editCreatorId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
  editCreatedAt: '2016-02-05 01:51:21',
  pageCreatorId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
  pageCreatedAt: '2015-05-31 17:58:29',
  seeDomainId: '<a href="0.json.html">0</a>',
  editDomainId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
  submitToDomainId: '<a href="0.json.html">0</a>',
  isAutosave: 'false',
  isSnapshot: 'false',
  isLiveEdit: 'true',
  isMinorEdit: 'false',
  indirectTeacher: 'false',
  todoCount: '33',
  isEditorComment: 'false',
  isApprovedComment: 'true',
  isResolved: 'false',
  snapshotText: '',
  anchorContext: '',
  anchorText: '',
  anchorOffset: '0',
  mergedInto: '',
  isDeleted: 'false',
  viewCount: '240',
  text: 'The problem of [5c ontology identification] is the problem of loading a goal into an [2c advanced agent] when that agent&#39;s representation of the world is likely to change in ways [5d unforeseen in the development phase].  This tutorial focuses primarily on explaining what the problem is and why it is a [6r foreseeable difficulty]; for the corresponding research problems, see [5c the main page on Ontology Identification].\n\nThis is a technical tutorial, meaning that it assumes some familiarity with [2v value alignment theory], the [6c value identification problem], and [2l safety thinking for advanced agents].\n\nTo isolate ontology identification from other parts of the value identification problem, we consider a simplified but still very difficult problem: to state an unbounded program implementing a [5g diamond maximizer] that will turn as much of the physical universe into diamond as possible.  The goal of &quot;making diamonds&quot; was chosen to have a crisp-seeming definition for our universe: namely, the amount of diamond is the number of carbon atoms covalently bound to four other carbon atoms.  Since it seems that in this case our [6h intended goal] should be crisply definable relative to our universe&#39;s physics, we can avert many other issues of trying to identify [5l complex values] to the agent.  Ontology identification is a difficulty that still remains even in this case - the agent&#39;s representation of &#39;carbon atoms&#39; may still change over time.\n\n## Introduction: Two sources of representational unpredictability\n\nSuppose we wanted to write a hand-coded, [5t object-level] utility function that evaluated the amount of diamond material present in the AI&#39;s model of the world.  We might foresee the following two difficulties:\n\n1.  Where exactly do I find &#39;carbon atoms&#39; inside the AI&#39;s model of the world?  As the programmer, all I see are these mysterious ones and zeroes, and the only parts that directly correspond to events I understand is the represention of the pixels in the AI&#39;s webcam... maybe I can figure out where the &#39;carbon&#39; concept is by showing the AI graphite, buckytubes, and a diamond on its webcam and seeing what parts get activated... whoops, looks like the AI just revised its internal representation to be more computationally efficient, now I once again have no idea what &#39;carbon&#39; looks like in there.  How can I make my hand-coded utility function re-bind itself to &#39;carbon&#39; each time the AI revises its model&#39;s representation of the world?\n\n2.  What exactly is &#39;diamond&#39;?  If you say it&#39;s a nucleus with six protons, what&#39;s a proton?  If you define a proton as being made of quarks, what if there are unknown other particles underlying quarks?  What if the Standard Model of physics is incomplete or wrong - can we state exactly and formally what constitutes a carbon atom when we aren&#39;t certain what the underlying quarks are made of?\n\nDifficulty 2 probably seems more exotic than the first, but Difficulty 2 is easier to explain in a formal sense and turns out to be a simpler way to illustrate many of the key issues that also appear in Difficulty 1.  We can see Difficulty 2 as the problem of binding an [6h intended goal] to an unknown territory, and Difficulty 1 as the problem of binding an intended goal to an unknown map.  So the first step of the tutorial will be to walk through how Difficulty 2 (what exactly is a diamond?) might result in weird behavior in an [107 unbounded agent] intended to be a diamond maximizer.\n\n## Try 1: Hacking AIXI to maximize diamonds?\n\nThe classic unbounded agent - an agent using far more computing power than the size of its environment - is [11v AIXI].  Roughly speaking, AIXI considers all computable hypotheses for how its environment might work - all possible Turing machines that would turn AIXI&#39;s outputs into AIXI&#39;s future inputs.  (The finite variant AIXI-tl has a hypothesis space that includes all Turing machines that can be specified using fewer than $l$ bits and run in less than time $t$.)\n\nFrom the perspective of AIXI, any Turing machine that takes one input tape and produces two output tapes is a &quot;hypothesis about the environment&quot;, where the input to the Turing machine encodes AIXI&#39;s hypothetical action, and the outputs are interpreted as a prediction about AIXI&#39;s sensory data and AIXI&#39;s reward signal.  (In Marcus Hutter&#39;s formalism, the agent&#39;s reward is a separate sensory input to the agent, so hypotheses about the environment also make predictions about sensed rewards).  AIXI then behaves as a [ Bayesian predictor] that uses [5v algorithmic complexity] to give higher [ prior probabilities] to simpler hypotheses (that is, Turing machines with fewer states and smaller state transition diagrams), and updates its mix of hypotheses based on sensory evidence (which can confirm or disconfirm the predictions of particular Turing machines).\n\nAs a decision agent, AIXI always outputs the motor action that leads to the highest predicted reward, assuming that the environment is described by the updated probability mixture of all Turing machines that could represent the environment (and assuming that future iterations of AIXI update and choose similarly).\n\nThe ontology identification problem shows up sharply when we imagine trying to modify AIXI to &quot;maximize expectations of diamonds in the outside environment&quot; rather than &quot;maximize expectations of sensory reward signals&quot;.  As a [ Cartesian agent], AIXI has sharply defined sensory inputs and motor outputs, so we can have a [ probability mixture] over all Turing machines that relate motor outputs to sense inputs (as crisply represented in the input and output tapes).  But even if some otherwise arbitrary Turing machine happens to predict sensory experiences extremely well, how do we look at the state and working tape of that Turing machine to evaluate &#39;the amount of diamond&#39; or &#39;the estimated number of carbon atoms bound to four other carbon atoms&#39;?  The highest-weighted Turing machines that have best predicted the sensory data so far, presumably contain *some* sort of representation of the environment, but we have no idea how to get &#39;the number of diamonds&#39; out of it.\n\n(Example:  Maybe one Turing machine that is producing good sequence predictions inside AIXI, actually does so by simulating a large universe, identifying a superintelligent civilization that evolves inside that universe, and motivating that civilization to try to intelligently predict future future bits from past bits (as provided by some intervention).  To write a formal utility function that could extract the &#39;amount of real diamond in the environment&#39; from arbitrary predictors in the above case , we&#39;d need the function to read the Turing machine, decode that universe, find the superintelligence, decode the superintelligence&#39;s thought processes, find the concept (if any) resembling &#39;diamond&#39;, and hope that the superintelligence had precalculated how much diamond was around in the outer universe being manipulated by AIXI.)\n\nThis is, in general, the reason why the AIXI family of architectures can only contain agents defined to maximize direct functions of their sensory input, and not agents that behave so as to optimize facts about their external environment.  (We can&#39;t make AIXI maximize diamonds by making it want *pictures* of diamonds because then it will just, e.g., [ build an environmental subagent that seizes control of AIXI&#39;s webcam and shows it pictures of diamonds].  If you ask AIXI to show itself sensory pictures of diamonds, you can get it to show its webcam lots of pictures of diamonds, but this is not the same thing as building an environmental diamond maximizer.)\n\n## Try 2: Unbounded agent using classical atomic hypotheses?\n\nGiven the origins of the above difficulty, we next imagine constraining the agent&#39;s hypothesis space to something other than &quot;literally all computable functions from motor outputs to sense inputs&quot;, so that we can figure out how to find diamonds or carbon inside the agent&#39;s representation of the world.\n\nAs an [ unrealistic example]:  Suppose someone was trying to define &#39;diamonds&#39; to the AI&#39;s utility function.  Suppose they knew about atomic physics but not nuclear physics.  Suppose they build an AI which, during its development phase, learns about atomic physics from the programmers, and thus builds a world-model that is based on atomic physics.\n\nAgain for purposes of [ unrealistic examples], suppose that the AI&#39;s world-model is encoded in such fashion that when the AI imagines a molecular structure - represents a mental image of some molecules - then carbon atoms are represented as a particular kind of basic element of the representation.  Again, as an [ unrealistic example], imagine that there are [ little LISP tokens] representing environmental objects, and that the environmental-object-type of carbon-objects is encoded by the integer 6.  Imagine also that each atom, inside this representation, is followed by a list of the other atoms to which it&#39;s covalently bound.  Then when the AI is imagining a carbon atom participating in a diamond, inside the representation we would see an object of type 6, followed by a list containing exactly four other 6-objects.\n\nCan we fix this representation for all hypotheses, and then write a utility function for the AI that counts the number of type-6 objects that are bound to exactly four other type-6 objects?  And if we did so, would the result actually be a diamond maximizer?\n\n### AIXI-atomic\n\nAs a first approach to implementing this idea - an agent whose hypothesis space is constrained to models that directly represent all the carbon atoms - imagine a variant of AIXI-tl that, rather than considering all tl-bounded Turing machines, considers all simulated atomic universes containing up to 10^100 particles spread out over up to 10^50 light-years.  In other words, the agent&#39;s hypotheses are universe-sized simulations of classical, pre-nuclear models of physics; and these simulations are constrained to a common representation, so a fixed utility function can look at the representation and count carbon atoms bound to four other carbon atoms.  Call this agent AIXI-atomic.\n\n(Note that AIXI-atomic, as an [107 unbounded agent], may use far more computing power than is embodied in its environment.  For purposes of the thought experiment, assume that the universe contains exactly one hypercomputer that runs AIXI-atomic.)\n\nA first difficulty is that universes composed only of classical atoms are not good explanations of our own universe, even in terms of surface phenomena; e.g. the [ultraviolet catastrophe](http://en.wikipedia.org/wiki/Ultraviolet_catastrophe).  So let it be supposed that we have simulation rules for classical physics that replicate at least whatever phenomena the programmers have observed at [ development time], even if the rules have some seemingly ad-hoc elements (like there being no ultraviolent catastrophes).  We will *not* however suppose that the programmers have discovered all experimental phenomena we now see as pointing to nuclear or quantum physics.\n\nA second difficulty is that a simulated universe of classical atoms does not identify where in the universe the AIXI-atomic agent resides, or say how to match the types of AIXI-atomic&#39;s sense inputs with the underlying behaviors of atoms.  We can elide this difficulty by imagining that AIXI-atomic simulates classical universes containing a single hypercomputer, and that AIXI-atomic knows a simple function from each simulated universe onto its own sensory data (e.g., it knows to look at the simulated universe, and translate simulated photons impinging on its webcam onto predicted webcam data in the standard format).  This elides most of the problem of [ naturalized induction].\n\nSo the AIXI-atomic agent that is hoped to maximize diamond:\n\n- Considers only hypotheses that directly represent universes as huge systems of classical atoms, so that the function &#39;count atoms bound to four other carbon atoms&#39; can be directly run over any possible future the agent models.\n- Assigns probabilistic priors over these possible atomic representations of the universe, favoring representations that are in some sense simpler.\n- Somehow [ maps each atomic-level representation onto the agent&#39;s predicted sensory experiences].\n- [ Bayes-updates its priors] based on actual sensory experiences, the same as classical AIXI.\n- Can evaluate the &#39;expected diamondness on the next turn&#39; of a single action by looking at all hypothetical universes where that action is performed, weighted by their current probability, and summing over the expectation of &#39;carbon atoms bound to four other carbon atoms&#39; after some unit amount of time has passed.\n- Can evaluate the &#39;future expected diamondness&#39; of an action, over some finite time horizon, by assuming that its future self will also Bayes-update and maximize expected diamondness over that time horizon.\n- On each turn, outputs the action with greatest expected diamondness over some finite time horizon.\n\nSuppose our own real universe was amended to otherwise be exactly the same, but contain a single [ impermeable] hypercomputer.  Suppose we defined an agent like the one above, using simulations of 1910-era models of physics, and ran that agent on the hypercomputer.  Should we expect the result to be an actual diamond maximizer - expect that the outcome of running this program on a single hypercomputer would indeed be that most mass in our universe would be turned into carbon and arranged into diamonds?\n\n### Anticipated failure: AIXI-atomic tries to &#39;maximize outside the simulation&#39;\n\nIn fact, our own universe isn&#39;t atomic, it&#39;s nuclear and quantum-mechanical.  This means that AIXI-atomic does not contain any hypotheses in its hypothesis space that *directly represent* our universe.  By the previously specified hypothesis of the thought experiment, AIXI-atomic&#39;s model of simulated physics was built to encompass all the experimental phenomena the programmers had yet discovered, but there were some quantum and nuclear phenomena that AIXI-atomic&#39;s programmers had not yet discovered.  When those phenomena are discovered, there will be no simple explanation on the direct terms of the model.\n\nIntuitively, of course, we&#39;d like AIXI-atomic to discover the composition of nuclei, shift its models to use nuclear physics, and refine the &#39;carbon atoms&#39; mentioned in its utility function to mean &#39;atoms with nuclei containing six protons&#39;.\n\nBut we didn&#39;t actually specify that when constructing the agent (and saying how to do it in general is, so far as we know, hard; in fact it&#39;s the whole ontology identification problem).  We constrained the hypothesis space to contain only universes running on the classical physics that the programmers knew about.  So what happens instead?\n\nProbably the &#39;simplest atomic hypothesis that fits the facts&#39; will be an enormous atom-based computer, *simulating* nuclear physics and quantum physics in order to create a simulated non-classical universe whose outputs are ultimately hooked up to AIXI&#39;s webcam.  From our perspective this hypothesis seems silly, but if you restrict the hypothesis space to only classical atomic universes, that&#39;s what ends up being the computationally simplest hypothesis that predicts, in detail, the results of nuclear and quantum experiments.\n\nAIXI-atomic will then try to choose actions so as to maximize the amount of expected diamond inside the probable *outside universes* that could contain the giant atom-based simulator of quantum physics.  It is not obvious what sort of behavior this would imply.\n\n### Metaphor for difficulty: AIXI-atomic cares about only fundamental carbon\n\nOne metaphorical way of looking at the problem is that AIXI-atomic was implicitly defined to care only about diamonds made out of *ontologically fundamental* carbon atoms, not diamonds made out of quarks.  A probability function that assigns 0 probability to all universes made of quarks, and a utility function that outputs a constant on all universes made of quarks, [ yield functionally identical behavior].  So it is an exact metaphor to say that AIXI-atomic only *cares* about universes with ontologically basic carbon atoms, given that AIXI-atomic&#39;s hypothesis space only contains universes with ontologically basic carbon atoms.\n\nImagine that AIXI-atomic&#39;s hypothesis space does contain many other universes with other laws of physics, but its hand-coded utility function just returns 0 on those universes since it can&#39;t find any &#39;carbon atoms&#39; inside the model.  Since AIXI-atomic only cares about diamond made of fundamental carbon, when AIXI-atomic discovers the experimental data implying that almost all of its probability mass should reside in nuclear or quantum universes in which there were no fundamental carbon atoms, AIXI-atomic stops caring about the effect its actions have on the vast majority of probability mass inside its model.  Instead AIXI-atomic tries to maximize inside the tiny remaining probabilities in which it *is* inside a universe with fundamental carbon atoms that is somehow reproducing its sensory experience of nuclei and quantum fields... for example, a classical atomic universe containing a computer simulating a quantum universe and showing the results to AIXI-atomic.\n\nFrom our perspective, we failed to solve the &#39;ontology identification problem&#39; and get the real-world result we [6h intended], because we tried to define the agent&#39;s *utility function* over properties of a universe made out of atoms, and the real universe turned out to be made of quantum fields.  This caused the utility function to *fail to bind* to the agent&#39;s representation in the way we intuitively had in mind.\n\nToday we do know about quantum mechanics, so if we tried to build a diamond maximizer using some bounded version of the above formula, it might not fail on account of [48 the particular exact problem] of atomic physics being false.\n\nBut perhaps there are discoveries still remaining that would change our picture of the universe&#39;s ontology to imply something else underlying quarks or quantum fields.  Human beings have only known about quantum fields for less than a century; our model of the ontological basics of our universe has been stable for less than a hundred years of our human experience.  So we should seek an AI design that does not assume we know the exact, true, fundamental ontology of our universe during an AI&#39;s [5d development phase].\n\nAs another important metaphorical case in point, consider a human being who feels angst on contemplating a universe in which &quot;By convention sweetness, by convention bitterness, by convention color, in reality only atoms and the void&quot; (Democritus); someone who wonders where there is any room in this collection of lifeless particles for love, free will, or even the existence of people.  Since, after all, people are just *mere* collections of atoms.  This person can be seen as undergoing an ontology identification problem: they don&#39;t know how to find the objects of value in a representation containing atoms instead of ontologically basic people.\n\nHuman beings simultaneously evolved a particular set of standard mental representations (e.g., a representation for colors in terms of a 3-dimensional subjective color space) along with evolving emotions that bind to these representations ([identification of flowering landscapes as beautiful](http://en.wikipedia.org/wiki/Evolutionary_aesthetics#Landscape_and_other_visual_arts_preferences).  When someone visualizes any particular configuration of &#39;mere atoms&#39;, their built-in desires don&#39;t automatically fire and bind to that mental representation, the way they would bind to the brain&#39;s native representation of the environment.  Generalizing that no set of atoms can be meaningful (since no abstract configuration of &#39;mere atoms&#39; they imagine, seems to trigger any emotions to bind to it) and being told that reality is composed entirely of such atoms, they feel they&#39;ve been told that the true state of reality, underlying appearances, is a meaningless one.\n\n## The utility rebinding problem\n\nIntuitively, we would think it was [ common sense] for an agent that wanted diamonds to react to the experimental data identifying nuclear physics, by deciding that a carbon atom is &#39;really&#39; a nucleus containing six protons.  We can imagine this agent [ common-sensically] updating its model of the universe to a nuclear model, and redefining the &#39;carbon atoms&#39; that its old utility function counted to mean &#39;nuclei containing exactly six protons&#39;.  Then the new utility function could evaluate outcomes in the newly discovered nuclear-physics universe.  The problem of producing this desirable agent behavior is the **utility rebinding problem**.\n\nTo see why this problem is nontrivial, consider that the most common form of carbon is C-12, with nuclei composed of six protons and six neutrons.  The second most common form of carbon is C-14, with nuclei composed of six protons and eight neutrons.  Is C-14 *truly* carbon - is it the sort of carbon that can participate in valuable diamonds of high utility?  Well, that depends on your utility function, obviously; and from a human perspective it just sounds arbitrary.\n\nBut consider a closely analogous question from a humanly important perspective: Is a chimpanzee truly a person?  Where the question means not, &quot;How do we arbitrarily define the syllables per-son?&quot; but &quot;Should we care a lot about chimpanzees?&quot;, i.e., how do we define the part of our preferences that care about people, to the possibly-person edge cases of chimpanzees?\n\nIf you live in a world where chimpanzees haven&#39;t been discovered, you may have an easy time running your utility function over your model of the environment, since the objects of your experience classify sharply into the &#39;person&#39; and &#39;nonperson&#39; categories.  Then you discover chimpanzees, and they&#39;re neither typical people (John Smith) nor typical nonpeople (like rocks).\n\nWe can see the force of this question as arising from something like an ontological shift: we&#39;re used to valuing cognitive systems that are made from whole human minds, but it turns out that minds are made of parts, and then we have the question of how to value things that are made from some of the person-parts but not all of them... sort of like the question of how to treat carbon atoms that have the usual number of protons but not the usual number of neutrons.\n\nChimpanzees definitely have neural areas of various sizes, and particular cognitive abilities - we can suppose the empirical truth is unambiguous at this level, and known to us.  So the question is then whether we regard a particular configuration of neural parts (a frontal cortex of a certain size) and particular cognitive abilities (consequentialist means-end reasoning and empathy, but no recursive language) as something that our &#39;person&#39; category values... once we&#39;ve rewritten the person category to value configurations of cognitive parts, rather than whole atomic people.\n\nIn fact, we run into this question as soon as we learn that human beings run on brains and the brains are made out of neural regions with functional properties; we can then *imagine* chimpanzees even if we haven&#39;t met any, and ask to what degree our preferences should treat this edge-person as deserving of moral rights.  If we can &#39;rebind&#39; our emotions and preferences to live in a world of nuclear brains rather than atomic people, this rebinding will *implicitly* say whether or not a chimpanzee is a person, depending on how our preference over brain configurations treats the configuration that is a chimpanzee.  \n\nIn this sense the problem we face with chimpanzees is exactly analogous to the question a diamond maximizer would face after discovering nuclear physics and asking itself whether a carbon-14 atom counted as &#39;carbon&#39; for purposes of caring about diamonds.  Once a diamond maximizer knows about neutrons, it can see that C-14 is chemically like carbon and forms the same kind of chemical bonds, but that it&#39;s heavier because it has two extra neutrons.  We can see that chimpanzees have a similar brain architectures to the sort of people we always considered before, but that they have smaller frontal cortexes and no ability to use recursive language, etcetera.\n\nWithout knowing more about the diamond maximizer, we can&#39;t guess what sort of considerations it might bring to bear in deciding what is Truly Carbon and Really A Diamond.  But the breadth of considerations human beings need to invoke in deciding how much to care about chimpanzees, is one way of illustrating that the problem of rebinding a utility function to a shifted ontology is [value-laden] and can potentially undergo [excursions] into [5l complex desiderata].  Redefining a [ moral category] so that it talks about the underlying parts of what were previously seen as all-or-nothing atomic objects, may carry an implicit ruling about how to value many kinds of [edge-case] objects that were never seen before.\n\nIt&#39;s possible that some formal part of this problem could be usefully carved out from the complex value-laded edge-case-reclassification part.  E.g., how would you redefine carbon as C12 if there were no other isotopes?  How would you rebind the utility function to *at least* C12?  In general, how could edge cases be [ identified and queried] by an [6w online Genie]?\n\n### Reappearance on the reflective level\n\nAn obvious thought (especially for [6w online Genies]) is that if the AI is unsure about how to reinterpret its goals in light of a shifting mental representation, it should query the programmers.\n\nSince the definition of a programmer would then itself be baked into the [5f preference framework], the problem might [ reproduce itself on the reflective level] if the AI became unsure of where to find &#39;programmers&#39;:  &quot;My preference framework said that programmers were made of carbon atoms, but all I can find in this universe are quantum fields!&quot;\n\nThus the ontology identification problem is arguably one of the [ critical subproblems] of value alignment: it plausibly has the property that, if botched, it could potentially [ crash the error recovery mechanism].\n\n## Diamond identification in multi-level maps\n\nA realistic, [5g bounded diamond maximizer] wouldn&#39;t represent the outside universe with atomically detailed or quantum-detailed models.  Instead, a bounded agent would have some version of a [ multi-level map] of the world in which the agent knew in principle that things were composed of atoms, but didn&#39;t model most things in atomic detail.  A bounded agent&#39;s model of an airplane would have wings, or wing shapes, rather than atomically detailed wings.  It would think about wings when doing aerodynamic engineering, atoms when doing chemistry, nuclear physics when doing nuclear engineering, and definitely not try to model everything in its experience down to the level of quantum fields.\n\nAt the present, there are not yet any proposed formalisms for how to do probability theory with multi-level maps (in other words: [ nobody has yet put forward a guess at how to solve the problem even given infinite computing power]).  But it seems very likely that, if we did know what multi-level maps looked like formally, it might suggest a formal solution to non-value-laden utility-rebinding.\n\nE.g., if an agent already has a separate high-level concept of &#39;diamond&#39; that&#39;s bound to a lower-level concept of &#39;carbon atoms bound to four other carbon atoms&#39;, then maybe when you discover nuclear physics, the multi-level map itself would tend to suggest that &#39;carbon atoms&#39; be re-bound to &#39;nuclei with six protons&#39; or &#39;nuclei with six protons and six neutrons&#39;.  It might at least be possible to phrase the equivalent of a prior or mixture of weightings for how the utility function would re-bind itself, and say, &quot;Given this prior, care about whatever that sparkly hard stuff &#39;diamond&#39; ends up binding to on the lower level.&quot;\n\nUnfortunately, we have very little formal probability theory to describe how a multi-level map would go from &#39;that unknown sparkly hard stuff&#39; to &#39;carbon atoms bound to four other carbon atoms in tetrahedral patterns, which is the only known repeating pattern for carbon atoms bound to four other carbon atoms&#39; to &#39;C12 and C14 are chemically identical but C14 is heavier&#39;.  This being the case, we don&#39;t know how to say anything about a dynamically updating multi-level map inside a [5f preference framework].\n\nIf we were actually trying to build a diamond maximizer, we would be likely to encounter this problem long before it started formulating new physics.  The equivalent of a computational discovery that changes &#39;the most efficient way to represent diamonds&#39; is likely to happen much earlier than a physical discovery that changes &#39;what underlying physical systems probably constitute a diamond&#39;.\n\nThis also means that we are liable to face the ontology identification problem long before the agent starts discovering new physics, as soon as it starts revising its representation.  Only very unreflective agents with strongly fixed-in-place representations for every part of the environment that we think the agent is supposed to care about, would let the ontology identification problem be elided entirely.  Only *very* not-self-modifying agents, or [ Cartesian agents] with goals formulated only over sense data, would not confront their programmers with ontology identification problems.\n\n## Research paths\n\nMore of these are described in the [5c main article on ontology identification].  But here&#39;s a quick list of some relevant research subproblems and avenues:\n\n* Transparent priors.  Priors that are constrained to meaningful hypothesis spaces that the utility function knows how to interpret.  Rather than all Turing machines being hypotheses, we could have only causal models being hypotheses, and then preference frameworks that talked about &#39;the cause of&#39; labeled sensory data could read the hypotheses.  (Note that the space of causal models can be Turing-complete, in the sense of being able to embed any Turing machine as a causal system.  So we&#39;d be able to explain any computable sense data in terms of a causal model - we wouldn&#39;t sacrifice any explanatory power by restricting ourselves to &#39;causal models&#39; instead of &#39;all Turing machines&#39;.)\n\n* Reductionist identifications.  Being able to go hunting, inside the current model of an environment, for a thingy that looks like it&#39;s made out of type-1 thingies bound to four other type-1 thingies, where a type-1 thingy is itself made out of six type-2, six type-3, and six type-4 thingies (6 electrons, 6 protons, 6 neutrons).\n\n* Causal identifications.  Some variation on trying to identify diamonds as the causes of pictures of diamonds, for some data set of things labeled as diamonds or non-diamonds.  This doesn&#39;t work immediately because then it&#39;s not clear whether &quot;the cause&quot; of the picture is the photons reflecting off the diamond, the diamond itself, the geological pressures that produced the diamond, the laws of physics, etcetera.  But perhaps some crossfire of identification could pin down the &#39;diamond&#39; category inside a causal model, by applying some formal rule to several sets of the right sort of labeled sense data.  As an open problem:  If an agent has a rich causal model that includes categories like &#39;diamond&#39; somewhere unknown, and you can point to labeled sensory datasets and use casual and categorical language, what labeled datasets and language would unambiguously identify diamonds, and no other white sparkly things, even if the resulting concept of &#39;diamond&#39; was being [2w subject to maximization]?  (Note that under this approach, as with any preference framework that talks about the causes of sensory experiences, we need to worry about [5j Christiano&#39;s Hack].)\n\n* Ambiguity resolution.  Detect when an ontology identification is ambiguous, and refer the problem to the user/programmer.  At our present stage of knowledge this seems like pretty much the same problem as [ inductive ambiguity resolution].\n\n* Multi-level maps.  Solve the problem of bounded agents having maps of the world that operate at multiple, interacting reductionist levels, as designed to save on computing power.  Then solve ontology identification by initially binding to a higher level of the map, and introducing some rule for re-binding as the map updates.  Note that multi-level mapping is an [ AGI rather than FAI problem], meaning that work here [ should perhaps be classified].\n\n* Solution for [6w non-self-modifying Genies].  Try to state a &#39;hack&#39; solution to ontology identification that would work for an AI running on fixed algorithms where a persistent knowledge representation is known at development time.\n\n## Some implications\n\nThe ontology identification problem is one more reason to believe that [ hard-coded object-level utility functions should be avoided] and that [ value identification in general is hard].\n\nOntology identification is heavily entangled with AGI problems, meaning that some research on ontology identification [ may need to be non-public].  This is an example instance of the argument that [ at least some VAT research may need to be non-public], based on that [ at least some AGI research is better off non-public].',
  metaText: '',
  isTextLoaded: 'true',
  isSubscribedToDiscussion: 'false',
  isSubscribedToUser: 'false',
  isSubscribedAsMaintainer: 'false',
  discussionSubscriberCount: '1',
  maintainerCount: '1',
  userSubscriberCount: '0',
  lastVisit: '2016-02-12 12:43:00',
  hasDraft: 'false',
  votes: [],
  voteSummary: [
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0'
  ],
  muVoteSummary: '0',
  voteScaling: '0',
  currentUserVote: '-2',
  voteCount: '0',
  lockedVoteType: '',
  maxEditEver: '0',
  redLinkCount: '0',
  lockedBy: '',
  lockedUntil: '',
  nextPageId: '',
  prevPageId: '',
  usedAsMastery: 'false',
  proposalEditNum: '0',
  permissions: {
    edit: {
      has: 'false',
      reason: 'You don&#39;t have domain permission to edit this page'
    },
    proposeEdit: {
      has: 'true',
      reason: ''
    },
    delete: {
      has: 'false',
      reason: 'You don&#39;t have domain permission to delete this page'
    },
    comment: {
      has: 'false',
      reason: 'You can&#39;t comment in this domain because you are not a member'
    },
    proposeComment: {
      has: 'true',
      reason: ''
    }
  },
  summaries: {},
  creatorIds: [
    '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
    '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>'
  ],
  childIds: [],
  parentIds: [
    '<a href="ontology_identification.json.html">ontology_identification</a>'
  ],
  commentIds: [],
  questionIds: [],
  tagIds: [],
  relatedIds: [],
  markIds: [],
  explanations: [],
  learnMore: [],
  requirements: [],
  subjects: [],
  lenses: [],
  lensParentId: '<a href="ontology_identification.json.html">ontology_identification</a>',
  pathPages: [],
  learnMoreTaughtMap: {},
  learnMoreCoveredMap: {},
  learnMoreRequiredMap: {},
  editHistory: {},
  domainSubmissions: {},
  answers: [],
  answerCount: '0',
  commentCount: '0',
  newCommentCount: '0',
  linkedMarkCount: '0',
  changeLogs: [
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '6450',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
      edit: '11',
      type: 'newEdit',
      createdAt: '2016-02-05 01:51:21',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '4270',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '10',
      type: 'newEdit',
      createdAt: '2015-12-23 03:34:59',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '4040',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
      edit: '9',
      type: 'newEdit',
      createdAt: '2015-12-17 01:26:03',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '3888',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
      edit: '8',
      type: 'newEdit',
      createdAt: '2015-12-16 05:56:57',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '3887',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
      edit: '0',
      type: 'newAlias',
      createdAt: '2015-12-16 05:56:56',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '307',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
      edit: '1',
      type: 'newParent',
      createdAt: '2015-10-28 03:46:51',
      auxPageId: '<a href="ontology_identification.json.html">ontology_identification</a>',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '1820',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '6',
      type: 'newEdit',
      createdAt: '2015-06-07 19:56:34',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '1819',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '5',
      type: 'newEdit',
      createdAt: '2015-06-07 19:56:08',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '1818',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '4',
      type: 'newEdit',
      createdAt: '2015-06-06 02:17:14',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '1817',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '3',
      type: 'newEdit',
      createdAt: '2015-06-04 02:24:30',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '1816',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '2',
      type: 'newEdit',
      createdAt: '2015-06-04 01:47:03',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '1815',
      pageId: '<a href="ontology_identification_technical_tutorial.json.html">ontology_identification_technical_tutorial</a>',
      userId: '<a href="EliezerYudkowsky.json.html">EliezerYudkowsky</a>',
      edit: '1',
      type: 'newEdit',
      createdAt: '2015-05-31 17:58:29',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    }
  ],
  feedSubmissions: [],
  searchStrings: {},
  hasChildren: 'false',
  hasParents: 'true',
  redAliases: {},
  improvementTagIds: [],
  nonMetaTagIds: [],
  todos: [],
  slowDownMap: 'null',
  speedUpMap: 'null',
  arcPageIds: 'null',
  contentRequests: {}
}</pre></body></html>