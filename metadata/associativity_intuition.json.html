<!DOCTYPE html><html><head><meta charset="utf-8"><title>Associativity: Intuition</title><link rel="stylesheet" type="text/css" href="../common.css"></head><body><pre style="white-space:pre-wrap">{
  localUrl: '<a href="../page/associativity_intuition.html">../page/associativity_intuition.html</a>',
  arbitalUrl: '<a href="https://arbital.com/p/associativity_intuition">https://arbital.com/p/associativity_intuition</a>',
  rawJsonUrl: '<a href="../raw/3kc.json">../raw/3kc.json</a>',
  likeableId: '<a href="2508.json.html">2508</a>',
  likeableType: 'page',
  myLikeValue: '0',
  likeCount: '2',
  dislikeCount: '0',
  likeScore: '2',
  individualLikes: [
    '<a href="EricBruylant.json.html">EricBruylant</a>',
    '<a href="NateSoares.json.html">NateSoares</a>'
  ],
  pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
  edit: '6',
  editSummary: 'added toc, duplicated summary so it shows in page',
  prevEdit: '5',
  currentEdit: '6',
  wasPublished: 'true',
  type: 'wiki',
  title: 'Associativity: Intuition',
  clickbait: '',
  textLength: '12927',
  alias: 'associativity_intuition',
  externalUrl: '',
  sortChildrenBy: 'likes',
  hasVote: 'false',
  voteType: '',
  votesAnonymous: 'false',
  editCreatorId: '<a href="EricBruylant.json.html">EricBruylant</a>',
  editCreatedAt: '2016-08-19 23:22:18',
  pageCreatorId: '<a href="NateSoares.json.html">NateSoares</a>',
  pageCreatedAt: '2016-05-15 07:16:27',
  seeDomainId: '<a href="0.json.html">0</a>',
  editDomainId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
  submitToDomainId: '<a href="0.json.html">0</a>',
  isAutosave: 'false',
  isSnapshot: 'false',
  isLiveEdit: 'true',
  isMinorEdit: 'false',
  indirectTeacher: 'false',
  todoCount: '0',
  isEditorComment: 'false',
  isApprovedComment: 'true',
  isResolved: 'false',
  snapshotText: '',
  anchorContext: '',
  anchorText: '',
  anchorOffset: '0',
  mergedInto: '',
  isDeleted: 'false',
  viewCount: '81',
  text: '[summary: Associative functions can be interpreted as families of functions that reduce lists down to a single output by combining adjacent elements in any order. Alternatively, associativity can be seen as a generalization of &quot;listyness,&quot; which captures and generalizes the &quot;it doesn&#39;t matter whether you added [a, b] to c or a to [b, c], the result is [a, b, c] regardless&quot; aspect of lists.\n\nThere are many different ways for a function to be associative, so it is difficult to provide a single litmus test for looking at a function and telling whether it associates (aside from just checking the associative axiom directly). However, a few heuristics can be used to make a good guess.]\n\nAssociative functions can be interpreted as families of functions that reduce lists down to a single output by combining adjacent elements in any order. Alternatively, associativity can be seen as a generalization of &quot;listyness,&quot; which captures and generalizes the &quot;it doesn&#39;t matter whether you added [a, b] to c or a to [b, c], the result is [a, b, c] regardless&quot; aspect of lists.\n\nThere are many different ways for a function to be associative, so it is difficult to provide a single litmus test for looking at a function and telling whether it associates (aside from just checking the associative axiom directly). However, a few heuristics can be used to make a good guess.\n\n[toc:]\n\n# Associative operators as natural functions on lists\n\nThe [3ms generalized associative law] says that an [3h4 associative] [3jy function] $f : X \\times X \\to X$ gives rise to a method for combining any non-empty list of $X$ elements into a single output, where the order in which adjacent elements are combined doesn&#39;t affect the result. We can flip that result around, and interpret associative operators as the pairwise versions of a certain class of &quot;natural&quot; functions for combining the elements of a list.\n\nOn this interpretation, we start by noting that some methods for reducing a list down to a single element can be broken down into pairwise combinations of adjacent elements, while others can&#39;t. For example, when we&#39;re trying to compute $3 + 4 + 5 + 6,$ we can pick any two adjacent elements and start by combining those using the binary version of $+$. But when we&#39;re trying to compute `adjacent_ones([0, 0, 0, 1, 1, 0])` to check whether the list has any two adjacent ones, we&#39;re going to run into trouble if we only look for adjacent ones in the pairs (0, 0), (0, 1), and (1, 0).\n\nThe lists that can be reduced by pairwise combination of adjacent pairs have a nice locality property; the result can be computed only by looking at adjacent elements (without worrying about the global structure). Locality is a common idiom in physics and mathematics, so we might start by asking what sort of functions on lists have this locality property. The answer is &quot;any list that can be broken down into pairwise combinations of elements such that the order doesn&#39;t matter.&quot; If we formalize that notion, we get the result that any function on lists with this locality property corresponds (in a one-to-one fashion) to an associative operation. Thus, we can view associativity as the mathematical formalization of this nice &quot;locality&quot; property on lists.\n\nEmpirically, this locality property turns out to be quite useful for math, physics, and in computer programming, as evidenced by the commonality of associative operators. See, for example, [3g8], or the pages on [algebraic_semigroup semigroups] and [3h3 monoids].\n\n# Associativity as a generalization of &quot;list&quot;\n\nThe above interpretation gives primacy to lists, and interprets associative operators in terms of natural functions on lists. We can invert that argument by treating associativity as a _generalization_ of what it means for something to act &quot;list-like.&quot;\n\nA list $[a, b, c, d, \\ldots]$ is a set of elements that have been combined by some &quot;combiner&quot; function, where the order of the elements matters, but the order _in which they were combined_ does not matter. For example, if we combine $a$ with $b$ (forming $[a, b]$) and then combine that with $c$, then we get the same list as if we combine $b$ and $c$ into $[b, c]$ first, and then combine $a$ with that.\n\nThe very fact that we can unambiguously say &quot;the list $[a, b, c]$&quot; without worrying about the order that the elements were combined in means that lists are built out of an associative &quot;combination&quot; operator. On this interpretation, associativity is capturing part of the essence of listyness, and associativity _in general_ generalizes this notion. For example, associative operators are allowed to be a little forgetful about what exact elements you combined (e.g., 3 + 4 = 2 + 5) so long as you retain the &quot;it doesn&#39;t matter what order you combine the things in&quot; property. In other words, we can view associativity as &quot;part of what it means to be list-like.&quot;\n\n(One particularly important property of lists &amp;mdash; namely, that they can be empty &amp;mdash; is not captured by associativity alone. Associative operators on sets that have an element that acts like an &quot;empty list&quot; are called &quot;monoids.&quot; For more on the idea of generalizing the notion of &quot;list&quot;, refer to the page on [3h3 monoids].)\n\n# Associative mechanisms\n\nThe above two interpretations give an intuition for what it _means_ that a function is associative. This still leaves open the question of _how_ a function can be associative. Imagine $f : X \\times X \\to Y$ as a [3mb physical mechanism] of wheels and gears. Someone says &quot;$f$ is associative.&quot; What does that _mean,_ in terms of the function&#39;s physical mechanisms? What should we expect to see when we pop the function open, given the knowledge that it &quot;is associative&quot;?\n\nRecall that associativity says that the two methods for combining two instantiations of the function yield the same output:\n\n![Associative paths](http://i.imgur.com/Ezs1P8l.png)\n\nThus, the ultimate physical test of associativity is hooking up two instantiations of $f$ as in the left diagram, and then checking whether dragging the mechanisms of the lower-right instantiation above the mechanisms of the upper-left instantiation (thereby reconfiguring the system according to the diagram on the right) causes the behavior of the overall system to change. What happens when the right-hand-side instantiation is given access to the middle input first versus second? Does that affect the behavior at all? If not, $f$ is associative.\n\nThis is not always an easy property to check by looking at the mechanisms of $f$ alone, and sometimes functions that appear non-associative (at first glance) turn out to be associative by apparent coincidence. In other words, there are many different ways for a function to be associative, so it is difficult to give a single simple criterion for determining associativity by looking at the internals of the function. However, we can use a few heuristics that help one distinguish associative functions from non-associative ones.\n\n## Heuristic: Can two copies of the function operate in parallel?\n\n$f$ is associative if, when using two copies of $f$ to reduce three inputs to one output, then changing whether the right-hand copy gets access to the middle tape first vs second does not affect the output. One heuristic for checking whether this is the case is to check whether both copies of $f$ can make use of the middle input at the same time, without getting in each other&#39;s way. If so, $f$ is likely associative.\n\nFor example, consider an implementation of $+$ that gets piles of poker chips as input (where a pile of $n$ chips represents the number $n$) and computes the output by simply sweeping all the poker chips from its input belts onto its output belt. To  make a function that adds three piles of chips together, you could set up two two-pile adders in the configuration of the diagram on the left, but you could also have two two-tape sweepers operating on three tapes in parallel, such that they both sweep the middle tape. This parallelization wouldn&#39;t change the output, and thus $+$ is associative.\n\nBy contrast, consider a mechanism that takes wooden blocks as input, and glues them together, and nails silver-colored caps on either end of the glued block. For example, if you put in a red block on the left and a blue block on the right, you get a silver-red-blue-silver block in the output. You could set up two copies of these like the diagram on the left, but if you tired to parallelize them, you&#39;d get into trouble &amp;mdash; each mechanism would be trying to nail one of its caps into the place that the other mechanism was attempting to apply glue. And indeed, this mechanism is non-associative.\n\nThis heuristic is imperfect. Some mechanisms that seem difficult to parallelize are still associative. For example, consider the multiplier mechanism, which takes two poker piles as input and puts a copy of the left pile onto the output tape for every chip in the right pile. It would be difficult to parallelize two copies of this function: One would be trying to count the chips in the middle pile while the other was attempting to copy the chips in the middle pile, and the result might not be pretty. However, multiplication _is_ associative, because a pile of $x$-many copies of a ($y$ copies of $z$)-many poker chips has the same number of chips as a pile of ($x$ copies $y$)-many copies of $z$-many poker chips. \n\n## Heuristic: Does the output interpretation match both input interpretations?\n\nAnother (vaguer) heuristic is to ask whether the output of the function should _actually_ be treated as the same sort of thing as the input to the function. For example, recall the `adjacent_ones` function from above, which checks a list for adjacent ones, and returns `1` if it finds some and `0` otherwise. The inputs to `adjacent_ones` are 0 and 1, and the output is 0 or 1, but the output interpretation doesn&#39;t quite match the input interpretation: Intuitively, the output is _actually_ intended to mean &quot;yes there were adjacent ones&quot; or &quot;not here weren&#39;t adjacent ones&quot;, and so applying `adjacent_ones` to the output of `adjacent_ones` is possible but ill-advised. If there is a mismatch between the output interpretation and at least one of the input interpretations, then the function probably isn&#39;t associative.\n\nFor example, imagine a person who is playing a game that works as follows. The board has three positions: red, green, and blue. The player&#39;s objective is to complete as many clockwise red-green-blue cycles as possible, without ever backtracking in the counter-clockwise direction.\n\n![3-cycle board](http://i.imgur.com/bxCnXUs.png)\n\n Each turn, the game offers them a choice of one of the three spaces, and they get to choose whether or not to travel to that square or stay where they are. Clearly, their preferences depend on where they currently are: If they&#39;re on &quot;red&quot;, &quot;green&quot; is a good move and &quot;blue&quot; is a bad one; but if they&#39;re on &quot;blue&quot; then choosing &quot;green&quot; is ill-advised. We can consider a binary function $f$ which takes their current position on the left and the proposed position on the right, and returns the position that the player prefers. For example, $f(red,blue)=red,$ $f(red,green)=green,$ $f(blue,blue)=blue,$ $f(blue,green=blue).$ In this case, the interpretation of the left input is a &quot;player position,&quot; the interpretation of the right input is an &quot;offered move&quot;, and the interpretation of the output is the resulting &quot;player position.&quot; The output interpretation mismatches one of the input interpretations, which implies that $f$ probably isn&#39;t associative, and indeed it is not: $f(f(red, green), blue))=blue,$ whereas $f(red, f(green, blue))=red.$ The former expression can be interpreted as &quot;where the player would be if they started at red, and were then offered green, and were then offered blue.&quot; The latter expression doesn&#39;t have a great interpretation, because it&#39;s feeding the output of $f(green, blue)$ (a player position) in as an &quot;offered move.&quot;\n\nIf the interpretation of the output (in this case, &quot;player position&quot;) mismatches the interpretations of at least one of the inputs, then the function likely isn&#39;t associative. However, this heuristic is also imperfect: The most obvious interpretations of the inputs and outputs to the subtraction function are &quot;they&#39;re all just numbers,&quot; and subtraction still fails to associate.\n\n## Further discussion\n\nThere are many different ways for a function to be associative, so it is difficult to give a simple litmus test. The ultimate test is always to imagine using two copies of $f$ to combine three outputs into one, and check whether the result changes depending on whether the left-hand copy of $f$ gets to run first (in which case it gets to access the second input belt at the source) or second (in which case its right-hand input is the right-hand copy&#39;s output). For examples of functions that pass or fail this ultimate test, refer to the [3mt examples page].',
  metaText: '',
  isTextLoaded: 'true',
  isSubscribedToDiscussion: 'false',
  isSubscribedToUser: 'false',
  isSubscribedAsMaintainer: 'false',
  discussionSubscriberCount: '1',
  maintainerCount: '1',
  userSubscriberCount: '0',
  lastVisit: '',
  hasDraft: 'false',
  votes: [],
  voteSummary: 'null',
  muVoteSummary: '0',
  voteScaling: '0',
  currentUserVote: '-2',
  voteCount: '0',
  lockedVoteType: '',
  maxEditEver: '0',
  redLinkCount: '0',
  lockedBy: '',
  lockedUntil: '',
  nextPageId: '',
  prevPageId: '',
  usedAsMastery: 'false',
  proposalEditNum: '0',
  permissions: {
    edit: {
      has: 'false',
      reason: 'You don&#39;t have domain permission to edit this page'
    },
    proposeEdit: {
      has: 'true',
      reason: ''
    },
    delete: {
      has: 'false',
      reason: 'You don&#39;t have domain permission to delete this page'
    },
    comment: {
      has: 'false',
      reason: 'You can&#39;t comment in this domain because you are not a member'
    },
    proposeComment: {
      has: 'true',
      reason: ''
    }
  },
  summaries: {},
  creatorIds: [
    '<a href="NateSoares.json.html">NateSoares</a>',
    '<a href="EricBruylant.json.html">EricBruylant</a>'
  ],
  childIds: [],
  parentIds: [
    '<a href="associative_operation.json.html">associative_operation</a>'
  ],
  commentIds: [
    '<a href="3n2.json.html">3n2</a>'
  ],
  questionIds: [],
  tagIds: [
    '<a href="needs_clickbait_meta_tag.json.html">needs_clickbait_meta_tag</a>',
    '<a href="b_class_meta_tag.json.html">b_class_meta_tag</a>'
  ],
  relatedIds: [],
  markIds: [],
  explanations: [],
  learnMore: [],
  requirements: [],
  subjects: [],
  lenses: [],
  lensParentId: '<a href="associative_operation.json.html">associative_operation</a>',
  pathPages: [],
  learnMoreTaughtMap: {},
  learnMoreCoveredMap: {},
  learnMoreRequiredMap: {},
  editHistory: {},
  domainSubmissions: {},
  answers: [],
  answerCount: '0',
  commentCount: '1',
  newCommentCount: '0',
  linkedMarkCount: '0',
  changeLogs: [
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '18847',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="EricBruylant.json.html">EricBruylant</a>',
      edit: '6',
      type: 'newEdit',
      createdAt: '2016-08-19 23:22:18',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: 'added toc, duplicated summary so it shows in page'
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '18846',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="EricBruylant.json.html">EricBruylant</a>',
      edit: '0',
      type: 'newTag',
      createdAt: '2016-08-19 23:22:13',
      auxPageId: '<a href="b_class_meta_tag.json.html">b_class_meta_tag</a>',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '17141',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="EricBruylant.json.html">EricBruylant</a>',
      edit: '0',
      type: 'newTag',
      createdAt: '2016-07-19 02:15:32',
      auxPageId: '<a href="needs_clickbait_meta_tag.json.html">needs_clickbait_meta_tag</a>',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10432',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '0',
      type: 'newAlias',
      createdAt: '2016-05-15 13:24:36',
      auxPageId: '',
      oldSettingsValue: 'associative_function_intuition',
      newSettingsValue: 'associativity_intuition'
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10423',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '0',
      type: 'newAlias',
      createdAt: '2016-05-15 13:19:07',
      auxPageId: '',
      oldSettingsValue: 'associativity_intuition',
      newSettingsValue: 'associative_function_intuition'
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10424',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '5',
      type: 'newEdit',
      createdAt: '2016-05-15 13:19:07',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10407',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '0',
      type: 'newAlias',
      createdAt: '2016-05-15 12:07:41',
      auxPageId: '',
      oldSettingsValue: '3kc',
      newSettingsValue: 'associativity_intuition'
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10404',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '3',
      type: 'newEdit',
      createdAt: '2016-05-15 09:34:08',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10402',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '2',
      type: 'newEdit',
      createdAt: '2016-05-15 09:27:18',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10395',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '1',
      type: 'newEdit',
      createdAt: '2016-05-15 07:16:27',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '10162',
      pageId: '<a href="associativity_intuition.json.html">associativity_intuition</a>',
      userId: '<a href="NateSoares.json.html">NateSoares</a>',
      edit: '1',
      type: 'newParent',
      createdAt: '2016-05-12 23:32:05',
      auxPageId: '<a href="associative_operation.json.html">associative_operation</a>',
      oldSettingsValue: '',
      newSettingsValue: ''
    }
  ],
  feedSubmissions: [],
  searchStrings: {},
  hasChildren: 'false',
  hasParents: 'true',
  redAliases: {},
  improvementTagIds: [],
  nonMetaTagIds: [],
  todos: [],
  slowDownMap: 'null',
  speedUpMap: 'null',
  arcPageIds: 'null',
  contentRequests: {}
}</pre></body></html>