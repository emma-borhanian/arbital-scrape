<!DOCTYPE html><html><head><meta charset="utf-8"><title>&quot;I might try to introduce th...&quot;</title><link rel="stylesheet" type="text/css" href="../common.css"></head><body><pre style="white-space:pre-wrap">{
  localUrl: '<a href="../page/4jd.html">../page/4jd.html</a>',
  arbitalUrl: '<a href="https://arbital.com/p/4jd">https://arbital.com/p/4jd</a>',
  rawJsonUrl: '<a href="../raw/4jd.json">../raw/4jd.json</a>',
  likeableId: '<a href="0.json.html">0</a>',
  likeableType: 'page',
  myLikeValue: '0',
  likeCount: '0',
  dislikeCount: '0',
  likeScore: '0',
  individualLikes: [],
  pageId: '<a href="4jd.json.html">4jd</a>',
  edit: '1',
  editSummary: '',
  prevEdit: '0',
  currentEdit: '1',
  wasPublished: 'true',
  type: 'comment',
  title: '&quot;I might try to introduce th...&quot;',
  clickbait: '',
  textLength: '1545',
  alias: '4jd',
  externalUrl: '',
  sortChildrenBy: 'recentFirst',
  hasVote: 'false',
  voteType: '',
  votesAnonymous: 'false',
  editCreatorId: '<a href="EricRogstad.json.html">EricRogstad</a>',
  editCreatedAt: '2016-06-17 18:32:46',
  pageCreatorId: '<a href="EricRogstad.json.html">EricRogstad</a>',
  pageCreatedAt: '2016-06-17 18:32:46',
  seeDomainId: '<a href="0.json.html">0</a>',
  editDomainId: '<a href="AlexeiAndreev.json.html">AlexeiAndreev</a>',
  submitToDomainId: '<a href="0.json.html">0</a>',
  isAutosave: 'false',
  isSnapshot: 'false',
  isLiveEdit: 'true',
  isMinorEdit: 'false',
  indirectTeacher: 'false',
  todoCount: '0',
  isEditorComment: 'true',
  isApprovedComment: 'true',
  isResolved: 'false',
  snapshotText: '',
  anchorContext: 'Imagine you are the Count von Count\\. You care only about counting things\\. You don&#39;t care what it is you count, you just care how many there are\\. You decide that you want to collect the objects that you count into boxes, and you consider two boxes equal if there are the same number of items in both boxes\\. How do you know if two boxes have the same number of items? You take one element out of each box and put them to one side\\. You continue pairing elements up in this way and when one box runs out you check if there are any left over in the other box\\. If there aren&#39;t any left over, then the boxes are bijective and the way that you paired them up is a bijection\\. A bijection is a simple form of an isomorphism and the boxes are said to be isomorphic\\.',
  anchorText: 'If there aren&#39;t any left over, then the boxes are bijective and the way that you paired them up is a bijection\\. A bijection is a simple form of an isomorphism and the boxes are said to be isomorphic\\.',
  anchorOffset: '561',
  mergedInto: '',
  isDeleted: 'false',
  viewCount: '234',
  text: 'I might try to introduce these terms one at a time, and a bit more slowly -- the paragraph up to this point reads like [Simple English](https://en.wikipedia.org/wiki/Simple_English) (good!), and then in the last two sentences I&#39;ve got two terms thrown at me.\n\nI think if a reader doesn&#39;t yet know what an isomorphism is, it would be helpful to spend more time building the intuition that there&#39;s something the same about both boxes, maybe like this:\n\n&gt; If there aren&#39;t any left over, then you know there were the same number of items in each box. So to Count von Count, who only cares about counting things, the two boxes are basically equivalent, and might as well be the same box. Whenever two objects are the *same* from a certain perspective, we say that they are *isomorphic*.\n\n&gt; In this example, the way in which the boxes were the same is that you could pair up each item in one box with an item in the other (which you wouldn&#39;t have been able to do if the boxes had different numbers of elements). Whenever you can match each item in one set with exactly one item in another set, we say that the sets are [-bijective] and the way you paired them is a [-bijection]. %%note: Note that two sets have to have the same number of elements to be bijective, but that&#39;s not enough &amp;mdash; you also need some way to say which item in one should be paired with which item in the other. In the case above, we paired the items up using the order in which they were removed from their boxes.%% A bijection is a kind of isomorphism.\n\nWhat do you think?',
  metaText: '',
  isTextLoaded: 'true',
  isSubscribedToDiscussion: 'false',
  isSubscribedToUser: 'false',
  isSubscribedAsMaintainer: 'false',
  discussionSubscriberCount: '1',
  maintainerCount: '1',
  userSubscriberCount: '0',
  lastVisit: '',
  hasDraft: 'false',
  votes: [],
  voteSummary: 'null',
  muVoteSummary: '0',
  voteScaling: '0',
  currentUserVote: '-2',
  voteCount: '0',
  lockedVoteType: '',
  maxEditEver: '0',
  redLinkCount: '0',
  lockedBy: '',
  lockedUntil: '',
  nextPageId: '',
  prevPageId: '',
  usedAsMastery: 'false',
  proposalEditNum: '0',
  permissions: {
    edit: {
      has: 'false',
      reason: 'You don&#39;t have domain permission to edit this page'
    },
    proposeEdit: {
      has: 'true',
      reason: ''
    },
    delete: {
      has: 'false',
      reason: 'You don&#39;t have domain permission to delete this page'
    },
    comment: {
      has: 'false',
      reason: 'You can&#39;t comment in this domain because you are not a member'
    },
    proposeComment: {
      has: 'true',
      reason: ''
    }
  },
  summaries: {},
  creatorIds: [
    '<a href="EricRogstad.json.html">EricRogstad</a>'
  ],
  childIds: [],
  parentIds: [
    '<a href="Isomorphism_intro_math_0.json.html">Isomorphism_intro_math_0</a>'
  ],
  commentIds: [],
  questionIds: [],
  tagIds: [],
  relatedIds: [],
  markIds: [],
  explanations: [],
  learnMore: [],
  requirements: [],
  subjects: [],
  lenses: [],
  lensParentId: '',
  pathPages: [],
  learnMoreTaughtMap: {},
  learnMoreCoveredMap: {},
  learnMoreRequiredMap: {},
  editHistory: {},
  domainSubmissions: {},
  answers: [],
  answerCount: '0',
  commentCount: '0',
  newCommentCount: '0',
  linkedMarkCount: '0',
  changeLogs: [
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '13644',
      pageId: '<a href="4jd.json.html">4jd</a>',
      userId: '<a href="EricRogstad.json.html">EricRogstad</a>',
      edit: '1',
      type: 'newEdit',
      createdAt: '2016-06-17 18:32:46',
      auxPageId: '',
      oldSettingsValue: '',
      newSettingsValue: ''
    },
    {
      likeableId: '<a href="0.json.html">0</a>',
      likeableType: 'changeLog',
      myLikeValue: '0',
      likeCount: '0',
      dislikeCount: '0',
      likeScore: '0',
      individualLikes: [],
      id: '13634',
      pageId: '<a href="4jd.json.html">4jd</a>',
      userId: '<a href="EricRogstad.json.html">EricRogstad</a>',
      edit: '1',
      type: 'newParent',
      createdAt: '2016-06-17 18:08:07',
      auxPageId: '<a href="Isomorphism_intro_math_0.json.html">Isomorphism_intro_math_0</a>',
      oldSettingsValue: '',
      newSettingsValue: ''
    }
  ],
  feedSubmissions: [],
  searchStrings: {},
  hasChildren: 'false',
  hasParents: 'true',
  redAliases: {},
  improvementTagIds: [],
  nonMetaTagIds: [],
  todos: [],
  slowDownMap: 'null',
  speedUpMap: 'null',
  arcPageIds: 'null',
  contentRequests: {}
}</pre></body></html>