<!DOCTYPE html><html><head><meta charset="utf-8"><title>Mild optimization</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Mild optimization</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/soft_optimizer.json.html">soft_optimizer.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/soft_optimizer">https://arbital.com/p/soft_optimizer</a></p><p class="creator">by
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a> Mar 21 2016 
updated
 Jun 20 2016</p></div><p class="clickbait">An AGI which, if you ask it to paint one car pink, just paints one car pink and doesn't tile the universe with pink-painted cars, because it's not trying *that* hard to max out its car-painting score.</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Mild optimization</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li><a href="AGI_typology.html">Strategic AGI typology</a></li><li><a href="task_agi.html">Task-directed AGI</a></li><li>…</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li><a href="task_agi.html">Task-directed AGI</a></li><li>…</li></ul></nav></nav></header><hr><main><p>[summary:  "Mild optimization" or "soft optimization" is when, if you ask the <a href="task_agi.html">genie</a> to paint one car pink, it just paints one car pink and then stops, rather than tiling the galaxies with pink-painted cars, because it's <em>not optimizing that hard.</em></p>
<p>This is related, but distinct from, notions like "<a href="low_impact.html">low impact</a>".  E.g., a low impact AGI might try to paint one car pink while minimizing its other footprint or how many other things changed, but it would be trying <em>as hard as possible</em> to minimize that impact and drive it down <em>as close to zero</em> as possible, which might come with its own set of pathologies.  What we want instead is for the AGI to try to paint one car pink while minimizing its footprint, and then, when that's being done pretty well, say "Okay done" and stop.</p>
<p>This is distinct from [eu_satisficer satisficing expected utility] because, e.g., rewriting yourself as an expected utility maximizer might also satisfice expected utility - there's no upper limit on how hard a satisficer approves of optimizing, so a satisficer is not <a href="reflective_stability.html">reflectively stable</a>.]</p>
<p>"Mild optimization" is where, if you ask a Task AGI to paint one car pink, it just paints one car pink and then stops, rather than tiling the galaxies with pink-painted cars, because it's <em>not optimizing that hard.</em>  It's okay with just painting one car pink; it isn't driven to max out the twentieth decimal place of its car-painting score.</p>
<p>Other <a href="https://www.facebook.com/yudkowsky/posts/10154053063684228">suggested terms</a> for this concept have included "soft optimization", "sufficient optimization", "minimum viable solution", "pretty good optimization", "moderate optimization", "regularized optimization", "sensible optimization", "casual optimization", "adequate optimization", "good-not-great optimization", "lenient optimization", "parsimonious optimization", and "optimehzation".</p>
<h1 id="differencefromlowimpact">Difference from low impact</h1>
<p>Mild optimization is complementary to <a href="task_goal.html">taskiness</a> and <a href="low_impact.html">low impact</a>.  A low impact AGI might try to paint one car pink while minimizing its other footprint or how many other things changed, but it would be trying <em>as hard as possible</em> to minimize that impact and drive it down <em>as close to zero</em> as possible, which might come with its own set of pathologies.</p>
<p>What we really want is both properties.  We want the AGI to paint one car pink in a way that gets the impact pretty low and then, you know, that's good enough - not have a cognitive pressure to search through weird extremes looking for a way to decrease the twentieth decimal place of the impact.  This would tend to break a low impact measure which contained even a subtle flaw, where a mild-optimizing AGI might not put as much pressure on the low impact measure and hence be less likely to break it.</p>
<p>(Obviously, what we <em>want</em> is a perfect low impact measure which will keep us safe <a href="omni_test.html">even if subjected to unlimited optimization power</a>, but a basic security mindset is to try to make each part safe on its own, then assume it might contain a flaw and try to design the rest of the system to be safe anyway.)</p>
<h1 id="differencefromsatisficing">Difference from satisficing</h1>
<p><a href="https://en.wikipedia.org/wiki/Satisficing#As_a_form_of_optimization">Satisficing utility functions</a> don't necessarily mandate or even allow mildness.</p>
<p>Suppose the AI's utility function is 1 when at least one car has been painted pink and 0 otherwise - there's no more utility to be gained by outcomes in which more cars have been painted pink.  Will this AI still go to crazy-seeming lengths?</p>
<p>Yes, because in a partially uncertain / probabilistic environment, there's still no upper bound on the utility which can be gained.  A solution with 0.9999 probability of painting at least one car pink is ranked above a solution with a 0.999 probability of painting at least one car pink.</p>
<p>If a preference ordering $~$&lt;_p$~$ has the property that for every probability distribution on expected outcomes $~$O$~$ there's another expected outcome $~$O'$~$ with $~$O &lt;_p O'$~$ which requires one more erg of energy to achieve, this is a sufficient condition for using up all the energy in the universe.  If converting all reachable matter into pink-painted cars implies a slightly higher probability, that at least one car is pink, that's the maximum of <em>expected</em> utility under the 0-1 utility function.</p>
<p>Less naive satisficing would describe an optimizer which satisfies an <em>expected</em> utility constraint - say, if any policy produces at least 0.95 <em>expected</em> utility under the 0-1 utility function, the AI can implement that policy.</p>
<p>This rule is now a <a href="task_goal.html">Task</a> and would at least <em>permit</em> mild optimization.  The problem is that it doesn't <em>exclude</em> extremely optimized solutions.  A 0.99999999 probability of producing at least one pink-painted car also has the property that it's above a 0.95 probability.  If you're a self-modifying satisficer, replacing yourself with a maximizer is probably a satisficing solution.</p>
<p>Even if we're not dealing with a completely self-modifying agent, there's a <em>ubiquity</em> of points where adding more optimization pressure might satisfice.  When you build a thermostat in the environment, you're coercing one part of the environment to have a particular temperature; if this kind of thing doesn't count as "more optimization pressure" then we could be dealing with all sorts of additional optimizing-ness that falls short of constructing a full subagent or doing a full self-modification.  There's all sorts of steps in cognition where it would be just as easy to add a maximizing step (take the highest-ranking solution) as to take a random high-ranking solution.</p>
<p>On a higher level of abstraction, the problem is that while satisficing is reflectively <em>consistent</em>, it's not <a href="reflective_stability.html">reflectively stable</a>.  A satisficing agent is happy to construct another satisficing agent, but it may also be happy to construct a maximizing agent.  It can approve its current mode of thinking, but it approves other modes of thinking too.  So unless <em>all</em> the cognitive steps are being carried out locally on <a href="KANSI.html">fixed known algorithms</a> that satisfice but definitely don't maximize, without the AGI constructing any environmental computations or conditional policy steps more complicated than a pocket calculator, building a seemingly mild satisficer doesn't guarantee that optimization <em>stays</em> mild.</p>
<h1 id="quantilizing">Quantilizing</h1>
<p>One weird idea that seems like it might exhibit incremental progress toward reflectively stable mild optimization is <a href="JessicaTaylor.html">Jessica Taylor</a>'s <a href="https://intelligence.org/files/QuantilizersSaferAlternative.pdf">expected utility quantilizer</a>.  Roughly, a quantilizer estimates expected outcomes relative to a null action, and then tries to produce an expected outcome in some <em>upper quantile</em> of possibilities - e.g., an outcome in the top 1% of expected outcomes.  Furthermore, a quantilizer <em>only</em> tries to narrow outcomes by that much - it doesn't try to produce one particular outcome in the top 1%; the most it will ever try to do is randomly pick an outcome such that this random distribution corresponds to being in the top 1% of expected outcomes.</p>
<p>Quantilizing corresponds to maximizing expected utility under the assumption that there is uncertainty about which outcomes are good and an adversarial process which can make some outcomes arbitrarily bad, subject to the constraint that the expected utility of the null action can only be boundedly low.  So if there's an outcome which would be very improbable given the status quo, the adversary can make that outcome be very bad.  This means that rather than aiming for one single high-utility outcome which the adversary could then make very bad, a quantilizer tries for a range of possible good outcomes.  This in turn means that quantilizers will actively avoid narrowing down the future too much, even if by doing so they'd enter regions of very high utility.</p>
<p>Quantilization doesn't seem like <em>exactly</em> what we actually want for multiple reasons.  E.g., if long-run good outcomes are very improbable given status quo, it seems like a quantilizer would try to have its policies fall short of that in the long run (a similar problem seems like it might appear in <a href="low_impact.html">impact measures</a> which imply that good long-run outcomes have high impact).</p>
<p>The key important idea that appears in quantilizing is that a quantilizer isn't just as happy to rewrite itself as a maximizer, and isn't just as happy to implement a policy that involves constructing a more powerful optimizer in the environment.</p>
<h1 id="relationtootherproblems">Relation to other problems</h1>
<p>Mild optimization relates directly to one of the three core reasons why aligning at-least-partially superhuman AGI is hard - making very powerful optimization pressures flow through the system puts a lot of stress on its potential weaknesses and flaws.  To the extent we can get mild optimization stable, it might take some of the critical-failure pressure off other parts of the system.  (Though again, basic security mindset says to still try to get all the parts of the system as flawless as possible and not tolerate any known flaws in them, <em>then</em> build the fallback options in case they're flawed anyway; one should not deliberately rely on the fallbacks and intend them to be activated.)</p>
<p>Mild optimization seems strongly complementary to <a href="low_impact.html">low impact</a> and <a href="task_goal.html">taskiness</a>.  Something that's merely low-impact might exhibit pathological behavior from trying to drive side impacts down to absolutely zero.  Something that merely optimizes mildly might find some 'weak' or 'not actually trying that hard' solution which nonetheless ended up turning the galaxies into pink-painted cars.  Something that has a satisfiable utility function with a readily-achievable maximum achievable utility might still go to tremendous lengths to drive the probability of achieving maximum utility to nearly 1.  Something that optimizes mildly <em>and</em> has a low impact penalty <em>and</em> has a small, clearly achievable goal, seems much more like the sort of agent that might, you know, just paint the damn car pink and then stop.</p>
<p>Mild optimization can be seen as a further desideratum of the currently open <a href="otherizer.html">Other-izer Problem</a>:  Besides being workable for <a href="bounded_agent.html">bounded agents</a>, and being <a href="reflective_stability.html">reflectively stable</a>, we'd <em>also</em> like an other-izer idiom to have a (stable) mildness parameter.</p>
<h1 id="approaches">Approaches</h1>
<p>It currently seems like the key subproblem in mild optimization revolves around <a href="reflective_stability.html">reflective stability</a> - we don't want "replace the mild optimization part with a simple maximizer, becoming a maximizer isn't that hard and gets the task done" to count as a 'mild' solution.  Even in human intuitive terms of "optimizing without putting in an unreasonable amount of effort", at some point a sufficiently advanced human intelligence gets lazy and starts building an AGI to do things for them because it's easier that way and only takes a bounded amount of effort.  We don't want "construct a second AGI that does hard optimization" to count as mild optimization even if it ends up not taking all that much effort for the first AGI, although "construct an AGI that does $~$\theta$~$-mild optimization" could potentially count as a $~$\theta$~$-mildsolution.</p>
<p>Similarly, we don't want to allow the deliberate creation of environmental or internal <a href="2rc">daemons</a> even if it's easy to do it that way or requires low effort to end up with that side effect - we'd want the optimizing power of such daemons to count against the measured optimization power and be rejected as optimizing too hard.</p>
<p>Since both of these phenomena seem hard to exhibit in current machine learning algorithms or faithfully represent in a toy problem, <a href="unbounded_analysis.html">unbounded analysis</a> seems likely to be the main way to go.  In general, it seems closely related to the <a href="otherizer.html">Other-izer Problem</a> which also seems most amenable to unbounded analysis at the present time.</p></main><hr><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a>,
 <a class="page-link" href="../page/taskagi_open_problems.html">Open subproblems in aligning a Task-based AGI</a></span></p><p class="all-creators"><h2>All Creators</h2><span class="page-comma-list"><a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a>,
 <a class="page-link" href="../page/PatrickLaVictoir.html">Patrick LaVictoire</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/PatrickLaVictoir.html">Patrick LaVictoire</a>,
 <a class="page-link" href="../page/RolandPihlakas.html">Roland Pihlakas</a></span></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a> <q>Tag for open problems under AI alignment.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/taskagi_open_problems.html">Open subproblems in aligning a Task-based AGI</a> <q>Open research problems, especially ones we can model today, in building an AGI that can &quot;paint all cars pink&quot; without turning its future light cone into pink-painted cars.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p></footer></body></html>