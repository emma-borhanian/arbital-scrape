<!DOCTYPE html><html><head><meta charset="utf-8"><title>Corrigibility</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Corrigibility</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/corrigibility.json.html">corrigibility.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/corrigibility">https://arbital.com/p/corrigibility</a></p><p class="creator">by
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a> Apr 5 2015 
updated
 Feb 8 2017</p></div><p class="clickbait">&quot;I can't let you do that, Dave.&quot;</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Corrigibility</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li>…</li></ul></nav></nav></header><hr><main><p>[summary:  Corrigible agents allow themselves to be 'corrected' (from our standpoint) by human <a href="value_alignment_programmer.html">programmers</a>, and don't experience <a href="instrumental_pressure.html">instrumental pressures</a> to avoid correction.</p>
<p>Imagine building an <a href="sufficiently_advanced_ai.html">advanced AI</a> with a <a href="shutdown_problem.html">shutdown button</a> that causes the AI to suspend to disk in an orderly fashion if the shutdown button is pressed.  An AI that is <em>corrigible</em> with respect to this shutdown button is an AI that doesn't try to prevent the shutdown button from being pressed… or rewrite itself without the shutdown code, or build a backup copy of itself elsewhere, or psychologically manipulate the programmers into not pressing the button, or fool the programmers into thinking the AI has shut down when it has not, etcetera.]</p>
<p>A 'corrigible' agent is one that <a href="nonadversarial.html">doesn&#39;t interfere</a> with what <a href="value_alignment_programmer.html">we</a> would intuitively see as attempts to 'correct' the agent, or 'correct' our mistakes in building it; and permits these 'corrections' despite the apparent <a href="instrumental_convergence.html">instrumentally convergent reasoning</a> saying otherwise.</p>
<ul>
<li>If we try to suspend the AI to disk, or shut it down entirely, a corrigible AI will let us do so.  (Even though, if suspended, <a href="no_coffee_if_dead.html">the AI will then be unable to fulfill what would usually be its goals</a>.)</li>
<li>If we try to reprogram the AI's utility function or <a href="meta_utility.html">meta-utility function</a>, a corrigible AI will allow this modification to go through.  (Rather than, e.g., fooling us into believing the utility function was modified successfully, while the AI actually keeps its original utility function as <a href="cognitive_steganography.html">obscured</a> functionality; as we would expect by default to be <a href="preference_stability.html">a preferred outcome according to the AI&#39;s current preferences</a>.)</li>
</ul>
<p>More abstractly:</p>
<ul>
<li>A corrigible agent experiences no preference or <a href="instrumental_pressure.html">instrumental pressure</a> to interfere with attempts by the programmers or operators to modify the agent, impede its operation, or halt its execution.</li>
<li>A corrigible agent does not attempt to manipulate or deceive its operators, especially with respect to properties of the agent that might otherwise cause its operators to modify it.</li>
<li>A corrigible agent does not try to <a href="cognitive_steganography.html">obscure its thought processes</a> from its programmers or operators.</li>
<li>A corrigible agent is motivated to preserve the corrigibility of the larger system if that agent self-modifies, constructs sub-agents in the environment, or offloads part of its cognitive processing to external systems; or alternatively, the agent has no preference to execute any of those general activities.</li>
</ul>
<p>A stronger form of corrigibility would require the AI to positively cooperate or assist, such that the AI would rebuild the shutdown button if it were destroyed, or experience a positive preference <em>not</em> to self-modify if self-modification could lead to incorrigibility.  But this is not part of the primary specification since it's possible that we would <em>not</em> want the AI trying to actively be helpful in assisting our attempts to shut it down, and would in fact prefer the AI to be passive about this.</p>
<p>Good proposals for achieving corrigibility in specific regards are <a href="value_alignment_open_problem.html">open problems in AI alignment</a>.  Some areas of active current research are <a href="utility_indifference.html">Utility indifference</a> and <a href="interruptibility.html">Interruptibility</a>.</p>
<p>Achieving total corrigibility everywhere via some single, general mental state in which the AI "knows that it is still under construction" or "believes that the programmers know more than it does about its own goals" is termed '<a href="hard_corrigibility.html">the hard problem of corrigibility</a>'.</p>
<h2 id="difficulties">Difficulties</h2>
<h3 id="deceptionandmanipulationbydefault">Deception and manipulation by default</h3>
<p>By default, most sets of preferences are such that an agent acting according to those preferences will prefer to retain its current preferences. For example, imagine an agent which is attempting to collect stamps. Altering the agent so that it prefers to collect bottle caps would lead to futures where the agent has fewer stamps, and so allowing this event to occur is dispreferred (under the current, stamp-collecting preferences).</p>
<p>More generally, as noted by <a href="instrumental_convergence.html">instrumentally convergent strategies</a>, most utility functions give an agent strong incentives to retain its current utility function: imagine an agent constructed so that it acts according to the utility function U, and imagine further that its operators think they built the agent to act according to a different utility function U'. If the agent learns this fact, then it has incentives to either deceive its programmers (prevent them from noticing that the agent is acting according to U instead of U') or manipulate its programmers (into believing that they actually prefer U to U', or by coercing them into leaving its utility function intact).</p>
<p>A corrigible agent must avoid these default incentives to manipulate and deceive, but specifying some set of preferences that avoids deception/manipulation incentives remains an open problem.</p>
<h3 id="troublewithutilityfunctionuncertainty">Trouble with utility function uncertainty</h3>
<p>A first attempt at describing a corrigible agent might involve specifying a utility maximizing agent that is uncertain about its utility function. However, while this could allow the agent to make some changes to its preferences as a result of observations, the agent would still be incorrigible when it came time for the programmers to attempt to correct what they see as mistakes in their attempts to formulate how the "correct" utility function should be determined from interaction with the environment.</p>
<p>As an overly simplistic example, imagine an agent attempting to maximize the internal happiness of all humans, but which has uncertainty about what that means. The operators might believe that if the agent does not act as intended, they can simply express their dissatisfaction and cause it to update. However, if the agent is reasoning according to an impoverished hypothesis space of utility functions, then it may behave quite incorrigibly: say it has narrowed down its consideration to two different hypotheses, one being that a certain type of opiate causes humans to experience maximal pleasure, and the other is that a certain type of stimulant causes humans to experience maximal pleasure. If the agent begins administering opiates to humans, and the humans resist, then the agent may "update" and start administering stimulants instead. But the agent would still be incorrigible — it would resist attempts by the programmers to turn it off so that it stops drugging people.</p>
<p>It does not seem that corrigibility can be trivially solved by specifying agents with uncertainty about their utility function. A corrigible agent must somehow also be able to reason about the fact that the humans themselves might have been confused or incorrect when specifying the process by which the utility function is identified, and so on.</p>
<h3 id="troublewithpenaltyterms">Trouble with penalty terms</h3>
<p>A second attempt at describing a corrigible agent might attempt to specify a utility function with "penalty terms" for bad behavior. This is unlikely to work for a number of reasons. First, there is the <a href="nearest_unblocked.html">Nearest unblocked strategy</a> problem: if a utility function gives an agent strong incentives to manipulate its operators, then adding a penalty for "manipulation" to the utility function will tend to give the agent strong incentives to cause its operators to do what it would have manipulated them to do, without taking any action that technically triggers the "manipulation" cause.  It is likely extremely difficult to specify conditions for "deception" and "manipulation" that actually rule out all undesirable behavior, especially if the agent is <a href="unforeseen_maximum.html">smarter than us</a> or <a href="context_disaster.html">growing in capability</a>.</p>
<p>More generally, it does not seem like a good policy to construct an agent that searches for positive-utility ways to deceive and manipulate the programmers, <a href="nonadversarial.html">even if those searches are expected to fail</a>. The goal of corrigibility is <em>not</em> to design agents that want to deceive but can't. Rather, the goal is to construct agents that have no incentives to deceive or manipulate in the first place: a corrigible agent is one that reasons as if it is incomplete and potentially flawed in dangerous ways.</p>
<h2 id="openproblems">Open problems</h2>
<p>Some open problems in corrigibility are:</p>
<h3 id="hardproblemofcorrigibility">Hard problem of corrigibility</h3>
<p>On a human, intuitive level, it seems like there's a central idea behind corrigibility that seems simple to us: understand that you're flawed, that your meta-processes might also be flawed, and that there's another cognitive system over there (the programmer) that's less flawed, so you should let that cognitive system correct you even if that doesn't seem like the first-order right thing to do.  You shouldn't disassemble that other cognitive system to update your model in a Bayesian fashion on all possible information that other cognitive system contains; you shouldn't model how that other cognitive system might optimally correct you and then carry out the correction yourself; you should just let that other cognitive system modify you, without attempting to manipulate how it modifies you to be a better form of 'correction'.</p>
<p>Formalizing the hard problem of corrigibility seems like it might be a problem that is hard (hence the name).  Preliminary research might talk about some obvious ways that we could model A as believing that B has some form of information that A's preference framework designates as important, and showing what these algorithms actually do and how they fail to solve the hard problem of corrigibility.</p>
<h3 id="ahrefutility_indifferencehtmlutilityindifferencea"><a href="utility_indifference.html">Utility indifference</a></h3>
<p>[fixme: explain utility indifference]</p>
<p>The current state of technology on this is that the AI behaves as if there's an absolutely fixed probability of the shutdown button being pressed, and therefore doesn't try to modify this probability.  But then the AI will try to use the shutdown button as an outcome pump.  Is there any way to avert this?</p>
<h3 id="percentalization">Percentalization</h3>
<p>Doing something in the top 0.1% of all actions.  This is actually a Limited AI paradigm and ought to go there, not under Corrigibility.</p>
<h3 id="conservativestrategies">Conservative strategies</h3>
<p>Do something that's as similar as possible to other outcomes and strategies that have been whitelisted.  Also actually a Limited AI paradigm.</p>
<p>This seems like something that could be investigate in practice on e.g. a chess program.</p>
<h3 id="lowimpactmeasure">Low impact measure</h3>
<p>(Also really a Limited AI paradigm.)</p>
<p>Figure out a measure of 'impact' or 'side effects' such that if you tell the AI to paint all cars pink, it just paints all cars pink, and doesn't transform Jupiter into a computer to figure out how to paint all cars pink, and doesn't dump toxic runoff from the paint into groundwater; and <em>also</em> doesn't create utility fog to make it look to people like the cars <em>haven't</em> been painted pink (in order to minimize this 'side effect' of painting the cars pink), and doesn't let the car-painting machines run wild afterward in order to minimize its own actions on the car-painting machines.  Roughly, try to actually formalize the notion of "Just paint the cars pink with a minimum of side effects, dammit."</p>
<p>It seems likely that this problem could turn out to be FAI-complete, if for example "Cure cancer, but then it's okay if that causes human research investment into curing cancer to decrease" is only distinguishable by us as an okay side effect because it doesn't result in expected utility decrease under our own desires.</p>
<p>It still seems like it might be good to, e.g., try to define "low side effect" or "low impact" inside the context of a generic Dynamic Bayes Net, and see if maybe we can find something after all that yields our intuitively desired behavior or helps to get closer to it.</p>
<h3 id="ambiguityidentification">Ambiguity identification</h3>
<p>When there's more than one thing the user could have meant, ask the user rather than optimizing the mixture.  Even if A is in some sense a 'simpler' concept to classify the data than B, notice if B is also a 'very plausible' way to classify the data, and ask the user if they meant A or B.  The goal here is to, in the classic 'tank classifier' problem where the tanks were photographed in lower-level illumination than the non-tanks, have something that asks the user, "Did you mean to detect tanks or low light or 'tanks and low light' or what?"</p>
<h3 id="safeoutcomepredictionanddescription">Safe outcome prediction and description</h3>
<p>Communicate the AI's predicted result of some action to the user, without putting the user inside an unshielded argmax of maximally effective communication.</p>
<h3 id="competenceaversion">Competence aversion</h3>
<p>To build e.g. a <a href="behaviorist.html">behaviorist genie</a>, we need to have the AI e.g. not experience an instrumental incentive to get better at modeling minds, or refer mind-modeling problems to subagents, etcetera.  The general subproblem might be 'averting the instrumental pressure to become good at modeling a particular aspect of reality'.  A toy problem might be an AI that in general wants to get the gold in a Wumpus problem, but doesn't experience an instrumental pressure to know the state of the upper-right-hand-corner cell in particular.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><p>Your characterization of utility indifference doesn't seem quite right. More accurate would be: the agent behaves as if it were certain the shutdown button won't do anything (because e.g. it is confident that a particular quantum coin will come up heads), and so won't bother to either eliminate or preserve it.</p>
<p>When presenting this problem, it seems best to lead with the underlying intuition about self-doubt, since I think that seems more interesting than the narrower applications (e.g. shutdown button). The narrower applications nicely show that self-doubt has clear meaningful consequences.</p></p></div></section><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a>,
 <a class="page-link" href="../page/nonadversarial.html">Non-adversarial principle</a>,
 <a class="page-link" href="../page/taskagi_open_problems.html">Open subproblems in aligning a Task-based AGI</a></span></p><p class="all-creators"><h2>All Creators</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexeiAndreev.html">Alexei Andreev</a>,
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a>,
 <a class="page-link" href="../page/MatthewGraves.html">Matthew Graves</a>,
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a>,
 <a class="page-link" href="../page/TsviBT.html">Tsvi BT</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/AndrewMcKnight.html">Andrew McKnight</a>,
 <a class="page-link" href="../page/JoshuaPratt.html">Joshua Pratt</a>,
 <a class="page-link" href="../page/LukeMcRedmond.html">Luke McRedmond</a>,
 <a class="page-link" href="../page/NickShesterin.html">Nick Shesterin</a>,
 <a class="page-link" href="../page/PatrickLaVictoir.html">Patrick LaVictoire</a></span></p><p class="related"><h2>Related</h2><ul class="page-list"><li><a class="page-link" href="../page/convergent_strategies.html">Convergent instrumental strategies</a> <q>Paperclip maximizers can make more paperclips by improving their cognitive abilities or controlling more resources.  What other strategies would almost-any AI try to use?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a> <q>Tag for open problems under AI alignment.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/nonadversarial.html">Non-adversarial principle</a> <q>At no point in constructing an Artificial General Intelligence should we construct a computation that tries to hurt us, and then try to stop it from hurting us.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/taskagi_open_problems.html">Open subproblems in aligning a Task-based AGI</a> <q>Open research problems, especially ones we can model today, in building an AGI that can &quot;paint all cars pink&quot; without turning its future light cone into pink-painted cars.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p><p class="children"><h2>Children</h2><ul class="page-tree"><li><a class="page-link" href="../page/avert_instrumental_pressure.html">Averting instrumental pressures</a> <q>Almost-any utility function for an AI, whether the target is diamonds or paperclips or eudaimonia, implies subgoals like rapidly self-improving and refusing to shut down.  Can we make that not happen?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/avert_self_improvement.html">Averting the convergent instrumental strategy of self-improvement</a> <q>We probably want the first AGI to *not* improve as fast as possible, but improving as fast as possible is a convergent strategy for accomplishing most things.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/hard_corrigibility.html">Hard problem of corrigibility</a> <q>Can you build an agent that reasons as if it knows itself to be incomplete and sympathizes with your wanting to rebuild or correct it?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/interruptibility.html">Interruptibility</a> <q>A subproblem of corrigibility under the machine learning paradigm: when the agent is interrupted, it must not learn to prevent future interruptions.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/updated_deference.html">Problem of fully updated deference</a> <q>Why moral uncertainty doesn't stop an AI from defending its off-switch.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/programmer_deception.html">Programmer deception</a> <q>Programmer deception is when the AI's decision process leads it to optimize for an instrumental goal…</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a><ul class="page-tree"><li><a class="page-link" href="../page/cognitive_steganography.html">Cognitive steganography</a> <q>Disaligned AIs that are modeling human psychology and trying to deceive their programmers will want to hide their internal thought processes from their programmers.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></li><li><a class="page-link" href="../page/shutdown_problem.html">Shutdown problem</a> <q>How to build an AGI that lets you shut it down, despite the obvious fact that this will interfere with whatever the AGI's goals are.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a><ul class="page-tree"><li><a class="page-link" href="../page/no_coffee_if_dead.html">You can't get the coffee if you're dead</a> <q>An AI given the goal of 'get the coffee' can't achieve that goal if it has been turned off; so even an AI whose goal is just to fetch the coffee may try to avert a shutdown button being pressed.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></li><li><a class="page-link" href="../page/user_manipulation.html">User manipulation</a> <q>If not otherwise averted, many of an AGI's desired outcomes are likely to interact with users and hence imply an incentive to manipulate users.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a><ul class="page-tree"><li><a class="page-link" href="../page/30b.html">User maximization</a> <q>A sub-principle of avoiding user manipulation - if you see an argmax over X or 'optimize X' instruction and X includes a user interaction, you've just told the AI to optimize the user.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></li><li><a class="page-link" href="../page/utility_indifference.html">Utility indifference</a> <q>How can we make an AI indifferent to whether we press a button that changes its goals?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p></footer></body></html>