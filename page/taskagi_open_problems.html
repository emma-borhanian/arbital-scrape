<!DOCTYPE html><html><head><meta charset="utf-8"><title>Open subproblems in aligning a Task-based AGI</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Open subproblems in aligning a Task-based AGI</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/taskagi_open_problems.json.html">taskagi_open_problems.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/taskagi_open_problems">https://arbital.com/p/taskagi_open_problems</a></p><p class="creator">by
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a> Mar 15 2016 
updated
 Apr 14 2016</p></div><p class="clickbait">Open research problems, especially ones we can model today, in building an AGI that can &quot;paint all cars pink&quot; without turning its future light cone into pink-painted cars.</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Open subproblems in aligning a Task-based AGI</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li><a href="AGI_typology.html">Strategic AGI typology</a></li><li><a href="task_agi.html">Task-directed AGI</a></li><li>…</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li><a href="task_agi.html">Task-directed AGI</a></li><li>…</li></ul></nav></nav></header><hr><main><p>MIRI and related organizations have recently become more interested in trying to sponsor (technical) work on <em>Task AGI</em> subproblems.  A <a href="task_agi.html">task-based agent</a>, aka Genie in Bostrom's lexicon, is an AGI that's meant to implement short-term goals identified to it by the users, rather than the AGI being a Bostromian "Sovereign" that engages in long-term strategic planning and self-directed, open-ended operations.</p>
<p>A Task AGI might be safer than a Sovereign because:</p>
<ul>
<li>It is possible to <a href="user_querying.html">query the user</a> before and during task performance, if an ambiguous situation arises and is successfully identified as ambiguous.</li>
<li>The tasks are meant to be limited in scope - to be accomplishable, once and for all, within a limited space and time, using some limited amount of effort.</li>
<li>The AGI itself can potentially be limited in various ways, since it doesn't need to be as powerful as possible in order to accomplish its limited-scope goals.</li>
<li>If the users can select a valuable and <em><a href="pivotal.html">pivotal</a></em> task, identifying an adequately <a href="advanced_safety.html">safe</a> way of accomplishing this task might be simpler than <a href="value_identification.html">identifying all of human value</a>.</li>
</ul>
<p>This page is about open problems in Task AGI safety that we think might be ready for further technical research.</p>
<h1 id="introductionthesafetaskagiproblem">Introduction: The safe Task AGI problem</h1>
<p>A safe Task AGI or safe Genie is an agent that you can safely ask to paint all the cars on Earth pink.</p>
<p><em>Just</em> paint all cars pink.</p>
<p>Not tile the whole future light cone with tiny pink-painted cars.  Not paint everything pink so as to be sure of getting everything that might possibly be a car.  Not paint cars white because white looks pink under the right color of pink light and white paint is cheaper.  Not paint cars pink by building nanotechnology that goes on self-replicating after all the cars have been painted.</p>
<p>The Task AGI superproblem is to formulate a design and training program for a real-world AGI that we can trust to just paint the damn cars pink.</p>
<p>To go into this at some greater depth, to build a safe Task AGI:</p>
<p>&bull; You need to be able to identify the goal itself, to the AGI, such that the AGI is then oriented on achieving that goal.   If you put a picture of a pink-painted car in front of a webcam and say "do this", all the AI has is the sensory pixel-field from the webcam.  Should it be trying to achieve more pink pixels in future webcam sensory data?  Should it be trying to make the programmer show it more pictures?  Should it be trying to make people take pictures of cars?  Assuming you can in fact identify the goal that singles out the futures to achieve, is the rest of the AI hooked up in such a way as to optimize that concept?</p>
<p>&bull; You need to somehow handle the <em>just</em> part of the <em>just paint the cars pink.</em>  This includes not tiling the whole future light cone with tiny pink-painted cars.  It includes not building another AI which paints the cars pink and then tiles the light cone with pink cars.  It includes not painting everything in the world pink so as to be sure of getting everything that might count as a car.  If you're trying to make the AI have "low impact" (intuitively, prefer plans that result in fewer changes to other quantities), then "low impact" must <em>not</em> include freezing everything within reach to minimize how much it changes, or making subtle changes to people's brains so that nobody notices their cars have been painted pink.</p>
<p>&bull; The AI needs to not shoot people who are standing between the painter and the car, and not accidentally run them over, and not use poisonous paint even if the poisonous paint is cheaper.</p>
<p>&bull; The AI should have an '<a href="abortable.html">abort</a>' button which gets it to safely stop doing what it's currently doing.  This means that if the AI was in the middle of building nanomachines, the nanomachines need to also switch off when the abort button is pressed, rather than the AI itself just shutting off and leaving the nanomachines to do whatever.  Assuming we have a safe measure of "low impact", we could define an "abortable" plan as one which can, at any time, be converted relatively quickly to one that has low impact.</p>
<p>&bull; The AI <a href="avert_instrumental_pressure.html">should not want</a> to self-improve or control further resources beyond what is necessary to paint the cars pink, and should <a href="user_querying.html">query the user</a> before trying to develop any <a href="conservative_concept.html">new</a> technology or assimilate any new resources it does need to paint cars pink.</p>
<p>This is only a preliminary list of some of the requirements and use-cases for a Task AGI, but it gives some of the flavor of the problem.</p>
<p>Further work on some facet of the open subproblems below might proceed by:</p>
<ol>
<li>Trying to explore examples of the subproblem and potential solutions within some contemporary machine learning paradigm.</li>
<li>Building a toy model of some facet of the subproblem, and hopefully observing some non-obvious fact that was not predicted in advance by existing researchers skilled in the art.</li>
<li>Doing <a href="unbounded_analysis.html">mathematical analysis</a> of an <a href="unbounded_analysis.html">unbounded agent</a> encountering or solving some facet of a subproblem, where the setup is sufficiently precise that claims about the consequences of the premise can be <a href="AI_safety_mindset.html">checked and criticized</a>.</li>
</ol>
<h1 id="ahrefconservative_concepthtmlconservatisma"><a href="conservative_concept.html">Conservatism</a></h1>
<p>A conservative concept boundary is a boundary which is (a) relatively simple and (b) classifies as few things as possible as positive instances of the category.</p>
<p>If we see that 3, 5, 13, and 19 are positive instances of a category and 4, 14, and 28 are negative instances, then a <em>simple</em> boundary which separates these instances is "All odd numbers."  A <em>simple and conservative</em> boundary is "All odd numbers between 3 and 19" or "All primes between 3 and 19".  (A non-simple boundary is "Only 3, 5, 13, and 19 are members of the category.")</p>
<p>E.g., if we imagine presenting an AI with smiling faces as instances of a goal concept to be learned, then a conservative concept boundary might lead the future AI to pursue only smiles attached to human heads, rather than tiny molecular smileyfaces (not that this necessarily solves everything).</p>
<p>If we imagine presenting the AI with 20 positive instances of a burrito, then a conservative boundary might lead the AI to produce a 21st burrito very similar to those.  Rather than, e.g., needing to explicitly present the AGI with a poisonous burrito that's labeled negative somewhere in the training data, in order to force the simplest boundary around the goal concept to be one that excludes poisonous burritos.</p>
<p>Conservative <em>planning</em> is a related problem in which the AI tries to create plans that are similar to previously whitelisted plans or to previous causal events that occur in the environment.  A conservatively planning AI, shown burritos, would try to create burritos via cooking rather than via nanotechnology, if the nanotechnology part wasn't especially necessary to accomplish the goal.</p>
<p>Detecting and flagging non-conservative goal instances or non-conservative steps of a plan for <a href="user_querying.html">user querying</a> is a related approach.</p>
<p>(<a href="conservative_concept.html">Main article.</a>)</p>
<h1 id="ahreflow_impacthtmlsafeimpactmeasurea"><a href="low_impact.html">Safe impact measure</a></h1>
<p>A low-impact agent is one that's intended to avoid large bad impacts at least in part by trying to avoid all large impacts as such.</p>
<p>Suppose we ask an agent to fill up a cauldron, and it fills the cauldron using a self-replicating robot that goes on to flood many other inhabited areas.  We could try to get the agent not to do this by letting it know that flooding inhabited areas is bad.  An alternative approach is trying to have an agent that avoids needlessly large impacts in general - there's a way to fill the cauldron that has a smaller impact, a smaller footprint, so hopefully the agent does that instead.</p>
<p>The hopeful notion is that while "bad impact" is a highly value-laden category with a lot of complexity and detail, the notion of "big impact" will prove to be simpler and to be more easily identifiable.  Then by having the agent avoid all big impacts, or check all big impacts with the user, we can avoid bad big impacts in passing.</p>
<p>Possible gotchas and complications with this idea include, e.g., you wouldn't want the agent to freeze the universe into stasis to minimize impact, or try to edit people's brains to avoid them noticing the effects of its actions, or carry out offsetting actions that cancel out the good effects of whatever the users were trying to do.</p>
<p>Two refinements of the low-impact problem are a <a href="shutdown_utility_function.html">shutdown utility function</a> and <a href="abortable.html">abortable plans</a>.</p>
<p>(<a href="low_impact.html">Main article.</a>)</p>
<h1 id="ahrefinductive_ambiguityhtmlidentifyingambiguousinductionsa"><a href="inductive_ambiguity.html">Identifying ambiguous inductions</a></h1>
<p>An 'inductive ambiguity' is when there's more than one simple concept that fits the data, even if some of those concepts are much simpler than others, and you want to figure out <em>which</em> simple concept was intended. </p>
<p>Suppose you're given images that show camouflaged enemy tanks and empty forests, but it so happens that the tank-containing pictures were taken on sunny days and the forest pictures were taken on cloudy days.  Given the training data, the key concept the user intended might be "camouflaged tanks", or "sunny days", or "pixel fields with brighter illumination levels".</p>
<p>The last concept is by far the simplest, but rather than just assume the simplest explanation is correct (has most of the probability mass), we want the algorithm (or AGI) to detect that there's more than one simple-ish boundary that might separate the data, and <a href="user_querying.html">check with the user</a> about <em>which</em> boundary was intended to be learned.</p>
<p>(<a href="inductive_ambiguity.html">Main article.</a>)</p>
<h1 id="ahrefsoft_optimizerhtmlmildoptimizationa"><a href="soft_optimizer.html">Mild optimization</a></h1>
<p>"Mild optimization" or "soft optimization" is when, if you ask the <a href="task_agi.html">Task AGI</a> to paint one car pink, it just paints one car pink and then stops, rather than tiling the galaxies with pink-painted cars, because it's <em>not optimizing that hard.</em></p>
<p>This is related, but distinct from, notions like "<a href="low_impact.html">low impact</a>".  E.g., a low impact AGI might try to paint one car pink while minimizing its other footprint or how many other things changed, but it would be trying <em>as hard as possible</em> to minimize that impact and drive it down <em>as close to zero</em> as possible, which might come with its own set of pathologies.  What we want instead is for the AGI to try to paint one car pink while minimizing its footprint, and then, when that's being done pretty well, say "Okay done" and stop.</p>
<p>This is distinct from [eu_satisficer satisficing expected utility] because, e.g., rewriting yourself as an expected utility maximizer might also satisfice expected utility - there's no upper limit on how hard a satisficer approves of optimizing, so a satisficer is not <a href="reflective_stability.html">reflectively stable</a>.</p>
<p>The open problem with mild optimization is to describe mild optimization that (a) captures what we mean by "not trying <em>so hard</em> as to seek out every single loophole in a definition of low impact" and (b) is <a href="reflective_stability.html">reflectively stable</a> and doesn't approve e.g. the construction of environmental subagents that optimize harder.</p>
<h1 id="ahrefpointing_fingerhtmllookwherei39mpointingnotatmyfingera"><a href="pointing_finger.html">Look where I&#39;m pointing, not at my finger</a></h1>
<p>Suppose we're trying to give a <a href="task_agi.html">Task AGI</a> the task, "Give me a strawberry".  User1 wants to identify their intended category of strawberries by waving some strawberries and some non-strawberries in front of the AI's webcam, and User2 in the control room will press a button to indicate which of these objects are strawberries.  Later, after the training phase, the AI itself will be responsible for selecting objects that might be potential strawberries, and User2 will go on pressing the button to give feedback on these.</p>
<p><img src="http://www.gliffy.com/go/publish/image/10423843/L.png" alt="strawberry diagram" /></p>
<p>The "look where I'm pointing, not at my finger" problem is getting the AI to focus on the strawberries rather than User2 - the concepts "strawberries" and "events that make User2 press the button" are very different goals even though they'll both well-classify the training cases; an AI might pursue the latter goal by psychologically analyzing User2 and figuring out how to get them to press the button using non-strawberry methods.</p>
<p>One way of pursuing this might be to try to zero in on particular nodes inside the huge causal lattice that ultimately produces the AI's sensory data, and try to force the goal concept to be about a simple or direct relation between the "potential strawberry" node (the objects waved in front of the webcam) and the observed button values, without this relation being allowed to go through the User2 node.</p>
<p><img src="http://www.gliffy.com/go/publish/image/10424137/L.png" alt="strawberry diagram" /></p>
<p>See also the related problem of "<a href="identify_causal_goals.html">Identifying causal goal concepts from sensory data</a>".</p>
<h1 id="moreopenproblems">More open problems</h1>
<p>This page is a work in progress.  A longer list of Task AGI open subproblems:</p>
<ul>
<li><a href="low_impact.html">Low impact</a></li>
<li><a href="shutdown_utility_function.html">Shutdown utility function</a><ul>
<li><a href="abortable.html">Abortable plans</a></li></ul></li>
<li><a href="conservative_concept.html">Conservatism</a></li>
<li><a href="soft_optimizer.html">Mild optimization</a></li>
<li><a href="avert_self_improvement.html">Aversion of instrumental self-improvement goal</a></li>
<li><a href="inductive_ambiguity.html">Ambiguity identification</a></li>
<li><a href="utility_indifference.html">Utility indifference</a></li>
<li><a href="shutdown_problem.html">Shutdown button</a></li>
<li>Task identification</li>
<li><a href="ontology_identification.html">Ontology identification</a></li>
<li><a href="identify_causal_goals.html">Identifying causal goal concepts from sensory data</a>
     - <a href="pointing_finger.html">Look where I&#39;m pointing, not at my finger</a></li>
<li>Hooking up a directable optimization to an identified task</li>
<li>Training protocols</li>
<li>Which things do you think can be well-identified by what kind of labeled datasets plus queried ambiguities plus conservatism, and what pivotal acts can you do with combinations of them plus assumed other abilities?</li>
<li><a href="faithful_simulation.html">Faithful simulation</a></li>
<li>Safe imitation for <a href="act_based_agents.html">act-based agents</a></li>
<li>Generative imitation with a probability of the human doing that act, guaranteed not to hindsight bias</li>
<li>Typicality (related to conservatism)</li>
<li>Plan transparency</li>
<li>Epistemic-only hypotheticals (when you ask how in principle how the AI might paint cars pink, it doesn't run a planning subprocess that plans to persuade the actual programmers to paint things pink).</li>
<li><a href="epistemic_exclusion.html">Epistemic exclusion</a></li>
<li><a href="behaviorist.html">Behaviorism</a></li>
</ul>
<p>(…more, this is a page in progress) </p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><p>On the act-based model, the user would say something like "paint all the cars pink," and the AI would take this as evidence about what individual steps the user would approve of. Effectiveness at painting all cars pink is one consideration that the user would use. Most of the problems on your list are other considerations that would affect the user's judgment.</p>
<p>The difference between us seems to be something like: I feel it is best to address almost all of these problems by using learning, and so I am trying to reduce them to a traditional learning problem. For example, I would like a human to reject plans that have huge side effects, and for the agent to learn that big side effects should be avoided. You don't expect that it will be easy to learn to address these problems, and so think that we should solve them ourselves to make sure they really get solved. (I think you called my position optimism about "special case sense.")</p>
<p>I might endorse something like your approach at some stage---once we have set everything up as a learning problem, we can ask what parts of the learning problem are likely to be especially difficult+important, and focus our efforts on making sure that systems can solve those problems (which may involve solving them ourselves, or may just involve differential ML progress). But it seems weird to me to start this way.</p>
<p>Some considerations that seem relevant to me:</p>
<ul>
<li>To the extent we can set up all of these problems as parts of a learning problem, it just seems like an empirical question which ones will be hard, and how hard they will be. I think that you are wrong about this empirical question, and you think I am wrong, but perhaps we can agree that it is an empirical question?</li>
<li>Setting things up as a learning problem is not only helpful for AI systems. It also automatically turns nebulous philosophical issues into precise technical problems, since they now correspond to e.g. receiving higher reward in some reinforcement learning environment.</li>
<li>In terms of comparative-advantage-across-time, it seems better for us to identify anything that can't be addressed by learning, and will require e.g. philosophical labor, and to postpone problems that might be addressed by learning or clever algorithms (since in the future people will have access to more powerful learning systems and cleverer algorithms)</li>
<li>The historical track record for hand-coding vs. learning is not good. For example, even probabilistic reasoning seems at this point like it's something that our agents should learn on their own (to the extent that probability is relevant to ML, it is increasingly as a technique relevant to analyzing ML systems rather than as a hard-coded feature of their reasoning). So it seems natural to first make sure that everything can be attacked as a learning problem, before trying to solve a bunch of particular learning problems by hand.</li>
</ul>
<p>It's possible that the difference between us is that I think it is <em>feasible</em> to reduce almost all of these problems to traditional learning problems, where you disagree. But when we've actually talked about it, you seem to have consistently opted for positions like "in some sense this is 'just' a prediction problem, but I suspect that solving it will require us to understand X." And concretely, it seems to me like we have an extremely promising approach for reducing most of these problems to learning problems.</p></p></div><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><blockquote class="comment-context">• You need to be able to identify the goal itself, to the AGI, such that the AGI is then oriented on achieving that goal\.   <mark>This isn't trivial for numerous reasons\.</mark>  If you put a picture of a pink\-painted car in front of a webcam and say "do this", all the AI has is the sensory pixel\-field from the webcam\.  Should it be trying to achieve more pink pixels in future webcam sensory data?  Should it be trying to make the programmer show it more pictures?  Should it be trying to make people take pictures of cars?  Assuming you can in fact identify the concept that singles out the futures to achieve, is the rest of the AI hooked up in such a way as to optimize that concept?</blockquote>
<p>I was talking to Chelsea Finn about IRL a few weeks ago, and she said that they had encountered the situation where they</p>
<ul>
<li>Demonstrated the intended behavior (I think it was putting a block into a slot)</li>
<li>Trained the robot to recognize success</li>
<li>Trained the robot reproduce that behavior, i.e. to do something it would recognize as success</li>
</ul>
<p>At which point it positioned the block so that it looked (to its cameras) like the block was in a slot, while in fact it was far away.</p>
<p>I think they then added joint position information so that the AI could more reliably estimate whether the block was in the slot, and that fixed the problem.</p>
<p>Of course this problem can be solved in many ways and this instance doesn't illustrate the full difficulty etc. but I think it's a nice illustration anyway.</p></p></div><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><blockquote class="comment-context">The problem of conservatism is an extension of the supervised learning problem in which, given labeled examples, we try to generate further cases that are almost certainly positive examples of a concept, rather than demanding that we label all possible further examples correctly\.  Another way of looking at it is that, given labeled training data, we don't just want to learn a simple concept that fits the labeled data, <mark>we want to learn a simple small concept that fits the data \- one that, subject to the constraint of labeling the training data correctly, predicts as few other positive examples as possible\.</mark></blockquote>
<p>Presumably the advantage of this approach---rather than simply learning to imitate the human burrito-making process or even human burritos, is that it might be easier to do. Is that right?</p>
<p>I think that's a valid goal, but I'm not sure how well "conservative generalizations" actually address the problem. Certainly it still leaves you at a significant disadvantage relative to a non-conservative agent, and it seems more natural to first consider direct approaches to making imitation effective (like bootstrapping + <a href="https://medium.com/ai-control/mimicry-maximization-and-meeting-halfway-c149dd23fc17">meeting halfway</a>).</p>
<p>Of course all of these approaches still involve a lot of extra work, so maybe the difference is are expectations about how different research angles will work out.</p></p></div><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><blockquote class="comment-context">In the context of a Task AGI, one application of what we call 'conservatism'  is the Burrito Problem\.  Suppose I show the AI five burritos and five non\-burritos\.  <mark>Rather than learning the simplest concept that distinguishes burritos from non\-burritos and then creating something that is maximally a burrito under this concept, we would like the AI to learn a simple and narrow concept that classifies these five things as burritos according to some simple rule</mark> \(not just the rule, "only these exact five objects are burritos"\) but which also classifies as few other objects as burritos as possible\.  This concept however must still be broad enough to permit the construction of a sixth burrito that is not molecularly identical to any of the first five\.  But not so broad that the burrito includes butolinum toxin \(because, hey, anything made out of mostly carbon\-hydrogen\-oxygen\-nitrogen that looks like a burrito ought to be fine\)\.</blockquote>
<p>To me, the most natural way to approach this is to take a probability distribution over "what it means to be a burrito," and to produce a thing that is maximally likely to be a burrito rather than a thing which is maximally burrito-like. Of course this still depends on having a good distribution over "what it means to be a burrito" (as does your approach).</p></p></div><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><blockquote class="comment-context">To put it another way, the task is to have the AI generate a safe burrito\.  <mark>One way to try to do this is making sure that the AI's explicit training data contains a burrito with butolinum toxin, labeled as a negative example, so that the AI knows not to include butolinum\.  The hope is that via conservatism we can avoid needing to think of every possible way that our training data might not properly stabilize the 'simplest explanation' along every dimension of potentially fatal variance, and shift some of the workload to just showing the AI positive examples which happen not to contain butolinum toxin\.</mark></blockquote>
<p>It seems critical to distinguish the cases where</p>
<ol>
<li>We are hoping the AI generalizes the concept of "burrito" in the intended way to new data,</li>
<li>The definition of burrito is "something our burrito-identifier would identify as a burrito given enough time," and we are just hoping the AI doesn't make mistakes. (The burrito-identifier is some process that we can actually run in order to determine whether something is a burrito.)</li>
</ol>
<p>As you've probably gathered, I feel hopeless about case (1).</p>
<p>In case (2), any agent that can learn the concept "definitely a burrito" could use this concept to produce definitely-burritos and thereby achieve high reward in the RL game. So the mere existence of the easy-to-learn definitely-a-burrito concept seems to imply that our learner will behave well. We don't have to actually explicitly do any work about conservative concepts (except to better understand the behavior of our learner).</p>
<p>I've never managed to get quite clear on your picture. My impression is that:</p>
<ul>
<li>you think that case (2) is doomed because there is no realistic prospect for creating a good enough burrito-evaluator, </li>
<li>you think that even with a good enough burrito-evaluator, you would still have serious trouble because of errors.</li>
</ul>
<p>I think your optimism about case (1) is defensible; I disagree, but not for super straightforward reasons.  The main disagreement is probably about case (2).</p>
<p>I think that your concern about generating a good enough burrito-evaluator is also defensible; I am optimistic, but even on my view this would require resolving a number of big research problems.</p>
<p>I think your concern about mistakes, and especially about something like "conservative concepts" as a way to reduce the scope for mistakes, is less defensible. I don't feel like this is as complex an issue---the case for delegating this to the learning algorithm seems quite strong, and I don't feel you've really given a case on the other side.</p>
<p>Note that this is related to what you've been calling <a href="inductive_ambiguity.html">Identifying ambiguous inductions</a>, and I do think that there are techniques in that space that could help avoid mistakes. (Though I would definitely frame that problem differently.) So it's possible we're not really disagreeing here either. But my best guess is that you are underestimating to the extent to which some of these issues could/should be delegated to the learner itself, supposing that we could resolve your other concerns (i.e. supposing that we could construct a good enough burrito-evaluator).</p></p></div><div class="comment"><p><a class="page-link" href="../page/EmmaBorhanian.html">Emma Borhanian</a></p><p><blockquote class="comment-context">If we see that 3, 5, 13, and 19 are positive instances of a category and 4, 14, and 28 are negative instances, then a simple boundary which separates these instances is "All odd numbers\."  A simple and conservative boundary is "All odd numbers between 3 and 19" or "All primes between 3 and 19"\.  \(<mark>A non\-simple boundary is "Only 3, 5, 13, and 19 are members of the category\."</mark>\)</blockquote>
<p>Is this really more complex than "All primes between 3 and 19"? I think you need more numbers before you can import the definition of prime and have that be simple.</p></p></div><div class="comment"><p><a class="page-link" href="../page/RyanCarey2.html">Ryan Carey</a></p><p><p>the strawberry diagrams are currently unavailable</p></p></div></section><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a>,
 <a class="page-link" href="../page/work_in_progress_meta_tag.html">Work in progress</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/AdeleLopez.html">Adele Lopez</a>,
 <a class="page-link" href="../page/AlexeiAndreev.html">Alexei Andreev</a>,
 <a class="page-link" href="../page/AndrewMcKnight.html">Andrew McKnight</a>,
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></span></p><p class="related"><h2>Related</h2><ul class="page-list"><li><a class="page-link" href="../page/avert_instrumental_pressure.html">Averting instrumental pressures</a> <q>Almost-any utility function for an AI, whether the target is diamonds or paperclips or eudaimonia, implies subgoals like rapidly self-improving and refusing to shut down.  Can we make that not happen?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/conservative_concept.html">Conservative concept boundary</a> <q>Given N example burritos, draw a boundary around what is a 'burrito' that is relatively simple and allows as few positive instances as possible.  Helps make sure the next thing generated is a burrito.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/corrigibility.html">Corrigibility</a> <q>&quot;I can't let you do that, Dave.&quot;</q> - <a class="page-link" href="../page/NateSoares.html">Nate Soares</a></li><li><a class="page-link" href="../page/faithful_simulation.html">Faithful simulation</a> <q>How would you identify, to a Task AGI (aka Genie), the problem of scanning a human brain, and then running a sufficiently accurate simulation of it for the simulation to not be crazy or psychotic?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/inductive_ambiguity.html">Identifying ambiguous inductions</a> <q>What do a &quot;red strawberry&quot;, a &quot;red apple&quot;, and a &quot;red cherry&quot; have in common that a &quot;yellow carrot&quot; doesn't?  Are they &quot;red fruits&quot; or &quot;red objects&quot;?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/identify_causal_goals.html">Identifying causal goal concepts from sensory data</a> <q>If the intended goal is &quot;cure cancer&quot; and you show the AI healthy patients, it sees, say, a pattern of pixels on a webcam.  How do you get to a goal concept *about* the real patients?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/informed_oversight.html">Informed oversight</a> <q>Incentivize a reinforcement learner that's less smart than you to accomplish some task</q> - <a class="page-link" href="../page/JessicaTaylor.html">Jessica Taylor</a></li><li><a class="page-link" href="../page/pointing_finger.html">Look where I'm pointing, not at my finger</a> <q>When trying to communicate the concept &quot;glove&quot;, getting the AGI to focus on &quot;gloves&quot; rather than &quot;my user's decision to label something a glove&quot; or &quot;anything that depresses the glove-labeling button&quot;.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/low_impact.html">Low impact</a> <q>The open problem of having an AI carry out tasks in ways that cause minimum side effects and change as little of the rest of the universe as possible.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/soft_optimizer.html">Mild optimization</a> <q>An AGI which, if you ask it to paint one car pink, just paints one car pink and doesn't tile the universe with pink-painted cars, because it's not trying *that* hard to max out its car-painting score.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/nonadversarial.html">Non-adversarial principle</a> <q>At no point in constructing an Artificial General Intelligence should we construct a computation that tries to hurt us, and then try to stop it from hurting us.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/safe_training_for_imitators.html">Safe training procedures for human-imitators</a> <q>How does one train a reinforcement learner to act like a human?</q> - <a class="page-link" href="../page/JessicaTaylor.html">Jessica Taylor</a></li><li><a class="page-link" href="../page/shutdown_problem.html">Shutdown problem</a> <q>How to build an AGI that lets you shut it down, despite the obvious fact that this will interfere with whatever the AGI's goals are.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a> <q>Tag for open problems under AI alignment.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/work_in_progress_meta_tag.html">Work in progress</a> <q>This page is being actively worked on by an editor. Check with them before making major changes.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p></footer></body></html>