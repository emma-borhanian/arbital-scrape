<!DOCTYPE html><html><head><meta charset="utf-8"><title>Algorithmic complexity</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Algorithmic complexity</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/Kolmogorov_complexity.json.html">Kolmogorov_complexity.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/Kolmogorov_complexity">https://arbital.com/p/Kolmogorov_complexity</a></p><p class="creator">by
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a> May 26 2015 
updated
 Jun 14 2016</p></div><p class="clickbait">When you compress the information, what you are left with determines the complexity.</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Algorithmic complexity</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="math.html">Mathematics</a></li><li><a href="information_theory.html">Information theory</a></li><li>â€¦</li></ul></nav></nav></header><hr><main><p>Algorithmic complexity is a formal measure of the minimum amount of information required to specify some message, binary string, computer program, classification rule, etcetera.  The algorithmic complexity or Kolmogorov complexity of a message is the number of 1s and 0s required to specify a Turing machine that reproduces the message.</p>
<p>(The relevant Wikipedia article is filed under <a href="http://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov complexity</a>.  Not to be confused with "<a href="complexity_theory.html">computational complexity</a>", which isn't the same thing at all.)</p>
<p>A string of a million 1s has around as much K-complexity as the number 1,000,000, since getting a Turing machine to print out exactly a million 1s and then stop, is mostly a matter of encoding the number 1,000,000.  The number 1,000,000 can itself potentially be compressed further, since it's an unusually simple number of that magnitude: it's 10 to the 6th power, so if we already have a concept of 'exponentiation' or can encode it simply, we just need to encode the numbers 10 and 6, which are quite small.</p>
<p>When we say that a message has high Kolmogorov complexity, we mean that it <em>can't be compressed beyond a certain point</em> (unless the 'compression algorithm' is itself large and contains much of the key information baked in).  Things have high Kolmogorov complexity when they're made up of many independent facts that can't be predicted from knowing the previous facts.</p>
<p>Shakespeare's <em>Romeo and Juliet</em> will compress by a lot using simple algorithms, because there are many words used more than once, and some words are much more frequent than others.  But we are exceedingly unlikely to find, anywhere in the first trillion Turing machines, any Turing machine that prints out the exact text of this play.  2^40 is greater than a trillion, so if we consider the set of all 40-bit binary strings, it's clear we can't print out <em>all</em> of them exactly using the first trillion Turing machines.  Finding a 40-bit Turing machine that printed out the exact text of <em>Romeo and Juliet</em> would be vastly improbable.</p>
<p>On the other hand, it wouldn't be particularly surprising to find a small Turing machine that printed out $~$3\uparrow\uparrow\uparrow3$~$ 1s and then stopped, because the algorithm for this enormous number seems simple, and easy to encode as a computer program or Turing machine.</p>
<p>The algorithmic complexity of a system shouldn't be confused with the total number of visible, complicated-looking details.  The <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> looks very complicated visually - you can keep zooming in using more and more detail - but there's a very simple rule that generates it, so we say the algorithmic complexity is very low. </p>
<p>As a corollary, a piece of a big-looking object can easily have more Kolmogorov complexity than the whole.  If you zoom far down into the Mandelbrot set and isolate a particular piece of the fractal, the information of that image now includes both the Mandelbrot-generating rule and also the exact location of that particular piece.</p>
<p>Similarly, the Earth is much more algorithmically complex than the laws of physics, and if there's a multiverse that developed deterministically out of the laws of physics, the Earth would be much more complex than that multiverse.  To print out the whole multiverse, you'd only need to start from the laws of physics and work forward; to print out <em>Earth in particular</em> you'd need a huge number of additional bits to locate Earth <em>inside</em> the multiverse.</p>
<p>Or more simply, we can observe that a program that prints out all possible books in order, is much simpler than a program that prints out only <em>Romeo and Juliet</em>.  To put it another way, Borge's "Library of Babel" containing every possible book has far lower algorithmic complexity than an Earth library containing only some books.  The moral is that the amount of visible stuff and its seeming surface complexity should not be confused with the notion of algorithmic complexity or theoretical compressibility.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/LancelotVerinia.html">Lancelot Verinia</a></p><p><p>It is not clear to me that:  </p>
<blockquote>
  <p>Or more simply, we can observe that a program that prints out all possible books in order, is much simpler than a program that prints out only Romeo and Juliet. To put it another way, Borge's "Library of Babel" containing every possible book has far lower algorithmic complexity than an Earth library containing only some books.   </p>
</blockquote>
<p>Is true. As far as I can tell, the above statement requires some of the following to be true:  </p>
<ol>
<li>The set of all possible books is something more like the set of all possible strings above a certain length (that the content of those strings be coherent, and constitute legitimate books is not required).</li>
<li>The shortest program encoding Romeo and Juliet in our reference UTM does so by explicitly locating it within the set of all possible books.</li>
</ol>
<p>I see no reason to assume that 2 is true, and I feel that if 1 is assumed, then it should be stated as such or it would be misleading.</p></p></div></section><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/definition_meta_tag.html">Definition</a>,
 <a class="page-link" href="../page/work_in_progress_meta_tag.html">Work in progress</a></span></p><p class="all-creators"><h2>All Creators</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexeiAndreev.html">Alexei Andreev</a>,
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a>,
 <a class="page-link" href="../page/JaimeSevillaMolina.html">Jaime Sevilla Molina</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a>,
 <a class="page-link" href="../page/SiddharthHiregowdara.html">Siddharth Hiregowdara</a></span></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/definition_meta_tag.html">Definition</a> <q>Meta tag used to mark pages that strictly define a particular term or phrase.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li><li><a class="page-link" href="../page/work_in_progress_meta_tag.html">Work in progress</a> <q>This page is being actively worked on by an editor. Check with them before making major changes.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p><p class="children"><h2>Children</h2><ul class="page-tree"><li><a class="page-link" href="../page/most_complexity_incompressible.html">Most complex things are not very compressible</a> <q>We can't *prove* it's impossible, but it would be *extremely surprising* to discover a 500-state Turing machine that output the exact text of &quot;Romeo and Juliet&quot;.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p></footer></body></html>