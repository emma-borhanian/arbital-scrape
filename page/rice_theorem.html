<!DOCTYPE html><html><head><meta charset="utf-8"><title>Rice's Theorem</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Rice's Theorem</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/rice_theorem.json.html">rice_theorem.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/rice_theorem">https://arbital.com/p/rice_theorem</a></p><p class="creator">by
 <a class="page-link" href="../page/PatrickStevens.html">Patrick Stevens</a> Jul 28 2016 
updated
 Aug 14 2016</p></div><p class="clickbait">Rice's Theorem tells us that if we want to determine pretty much anything about the behaviour of an arbitrary computer program, we can't in general do better than just running it.</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Rice's Theorem</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="math.html">Mathematics</a></li><li><a href="turing_machine.html">Turing machine</a></li><li>…</li></ul></nav></nav></header><hr><main><p>[summary: Rice's Theorem tells us that for <em>every</em> nontrivial property of computable functions, there is no general procedure which takes as its input a Turing machine, and computes whether or not the function computed by that machine has that property. That is, there is no general way to determine anything nontrivial about the output of an arbitrary Turing machine.]</p>
<p>Rice's Theorem is a rather surprising and very strong restriction on what we can determine about the <a href="function.html">Function</a> computed by an arbitrary <a href="turing_machine.html">Turing machine</a>.
It tells us that for <em>every</em> nontrivial property of computable functions %%note:By "nontrivial", we mean there is at least one function with that property and at least one without that property.%%, there is no general procedure which takes as its input a Turing machine, and computes whether or not the function computed by that machine has that property.</p>
<p>Therefore, if we want to discover anything about the output of a general computer program, <em>in general</em> the best we can do is simply run the program.
As a corollary, there can be no <em>fully general</em> procedure that checks whether a piece of computer code is free of bugs or not.</p>
<h1 id="formalstatement">Formal statement</h1>
<p>We will use the notation $~$[n]$~$ for the $~$n$~$th <a href="turing_machine.html">Turing machine</a> under some fixed [description_number numbering system].
Each such machine induces a <a href="partial_function.html">Partial function</a>, which we will also write as $~$[n]$~$ where this is unambiguous due to context; then it makes sense to write $~$[n](m)$~$ for the value that machine $~$[n]$~$ outputs when it is run on input $~$m$~$.</p>
<p>Let $~$A$~$ be a non-empty, proper %%note:That is, it is not the entire set.%% subset of $~$\{ \mathrm{Graph}(n) : n \in \mathbb{N} \}$~$, where $~$\mathrm{Graph}(n)$~$ is the [graph_of_a_function graph] of the <a href="partial_function.html">Partial function</a> computed by $~$[n]$~$, the $~$n$~$th Turing machine.
Then there is no Turing machine $~$[r]$~$ such that:</p>
<ul>
<li>$~$[r](i)$~$ is $~$1$~$ if $~$\mathrm{Graph}(i) \in A$~$</li>
<li>$~$[r](i)$~$ is $~$0$~$ if $~$\mathrm{Graph}(i) \not \in A$~$.</li>
</ul>
<h1 id="caveats">Caveats</h1>
<ul>
<li><p>While this result tells us, for example, that "no procedure will ever be able to determine whether an arbitrary program is bug-free", in practice it may be possible to determine whether <em>a large class</em> of programs is bug-free, while accepting the fact that our procedure might not be able to solve the fully general case.</p></li>
<li><p>Additionally, this result only tells us about the <em>graphs</em> of the functions in question.
We can determine certain properties which are specific to the Turing machine: for example, we can tell whether the program will halt in five steps, by simply running it for five steps.
This does not contradict Rice, because Rice tells us only about the ultimate answer the machines spit out, and nothing about the procedures they use to get to the answer; "the machine halts in five steps" is not a property of the graph of the function, but is a property of the Turing machine itself.</p></li>
<li><p>Rice's theorem is only a restriction on whether we can <em>decide</em> the status of a function: that is, whether we can decide <em>whether or not</em> the function computed by some machine has a certain property. Rice tells us nothing if we're only looking for a procedure that "must find out in finite time whether a function <em>does</em> have a property, but is allowed to never give an answer if the function <em>doesn't</em> have the property".
For example, we can determine whether a partial function is defined anywhere (that is, it is not the empty function: the one which never outputs anything, whatever its input) by just attempting to evaluate the function in parallel at $~$0$~$, at $~$1$~$, at $~$2$~$, and so on.
If the partial function is defined anywhere, then eventually one of the parallel threads will discover this fact; but if it is defined nowhere, then the procedure might just spin on and on forever without giving any output.
However, Rice's theorem does guarantee that there is no procedure which will tell us in finite time <em>whether or not</em> its input is a function which is defined somewhere; even though we have just specified a procedure which will tell us in finite time <em>if</em> its input is defined somewhere.</p></li>
</ul>
<h1 id="proofoutline">Proof outline</h1>
<p>Several proofs exist: for example, <a href="rice_and_halt.html">one by reduction</a> to the [halting_problem halting problem], and one <a href="proof_of_rice_theorem.html">standalone proof</a>.
Here, we sketch the standalone proof in broad strokes, because it goes via a neat lemma.</p>
<p>The intermediate lemma we prove is:</p>
<blockquote>
  <p>Let $~$h: \mathbb{N} \to \mathbb{N}$~$ be [total_function total] computable: that is, it halts on every input.
  Then there is $~$n \in \mathbb{N}$~$ such that $~$\mathrm{Graph}(n) = \mathrm{Graph}(h(n))$~$. %%note:And, moreover, we can actually <em>find</em> such an $~$n$~$.%%</p>
</blockquote>
<p>That is, the "underlying function" of $~$n$~$ - the partial function computed by $~$[n]$~$ - has the same output, at every point, as the function computed by $~$[h(n)]$~$.
If we view $~$h$~$ as a way of manipulating a program (as specified by its [-description_number]), then this fixed-point theorem states that we can find a program whose underlying function is not changed at all by $~$h$~$.</p>
<p>This lemma might be somewhat surprising: it "ought" to be possible to find a change one could make to arbitrary computer code, with the guarantee that the altered code must do something different to the original.
The fixed-point theorem tells us that this is not the case.</p>
<p>The proof of the lemma is very difficult to understand fully, but rather easy to state, because there are several useful shorthands which hide much of the complexity of what is really going on; full details, along with a worked example, can be found in <a href="proof_of_rice_theorem.html">the accompanying lens</a>.</p>
<p>Once we have the intermediate lemma, Rice's theorem itself follows quickly.
Indeed, if the operation of "determine whether a machine computes a function whose graph is in $~$A$~$ or not" is computable, then we can do the following procedure:</p>
<ul>
<li>Take some computer code as input.</li>
<li>Determine whether the code specifies a function whose graph is in $~$A$~$ or not.</li>
<li>If it is in $~$A$~$, output code for a specific (probably unrelated) function whose graph is <em>not</em> in $~$A$~$.</li>
<li>Otherwise, output code for a specific (probably unrelated) function whose graph is in $~$A$~$.</li>
</ul>
<p>The fixed-point theorem tells us that some program isn't changed by the above procedure; but the procedure is guaranteed to interchange programs-from-$~$A$~$ with programs-not-from-$~$A$~$, so the procedure can't have any fixed points after all.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/SylvainChevalier.html">Sylvain Chevalier</a></p><p><p>Is the difference between "<em>whether or not</em>" and "<em>if</em>" trivial in english (I'm French) ? I think I understand the third point in the Caveats section. However I only understand the last sentence from context. Is there already an explanation on Arbital of the difference between "<em>whether or not</em>" and "<em>if</em>" as used here ?</p></p></div></section><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/b_class_meta_tag.html">B-Class</a>,
 <a class="page-link" href="../page/math2.html">Math 2</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a>,
 <a class="page-link" href="../page/JaimeSevillaMolina.html">Jaime Sevilla Molina</a>,
 <a class="page-link" href="../page/PatrickStaples.html">Patrick Staples</a>,
 <a class="page-link" href="../page/SylvainChevalier.html">Sylvain Chevalier</a>,
 <a class="page-link" href="../page/VladArber.html">Vlad Arber</a></span></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/b_class_meta_tag.html">B-Class</a> <q>This page is mostly complete and without major problems, but has not had detailed feedback from the target audience and reviewers.</q> - <a class="page-link" href="../page/EricBruylant.html">Eric Bruylant</a></li><li><a class="page-link" href="../page/math2.html">Math 2</a> <q>Do you work with math on a fairly routine basis?  Do you have little trouble grasping abstract structures and ideas?</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p><p class="children"><h2>Children</h2><ul class="page-tree"><li><a class="page-link" href="../page/proof_of_rice_theorem.html">Proof of Rice's theorem</a> <q>A standalone proof of Rice's theorem, including one surprising lemma.</q> - <a class="page-link" href="../page/PatrickStevens.html">Patrick Stevens</a></li><li><a class="page-link" href="../page/6bf.html">Rice's Theorem: Intro (Math 1)</a> <q>You can't write a program that looks at another programs source code, and tells you whether it computes the Fibonacci sequence.</q> - <a class="page-link" href="../page/DylanHendrickson.html">Dylan Hendrickson</a></li><li><a class="page-link" href="../page/rice_and_halt.html">Rice's theorem and the Halting problem</a> <q>We will show that Rice's theorem and the the halting problem are equivalent.

#The Halting theorem i…</q> - <a class="page-link" href="../page/JaimeSevillaMolina.html">Jaime Sevilla Molina</a></li></ul></p></footer></body></html>