<!DOCTYPE html><html><head><meta charset="utf-8"><title>Diamond maximizer</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Diamond maximizer</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/diamond_maximizer.json.html">diamond_maximizer.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/diamond_maximizer">https://arbital.com/p/diamond_maximizer</a></p><p class="creator">by
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a> Apr 27 2015 
updated
 Dec 17 2015</p></div><p class="clickbait">How would you build an agent that made as much diamond material as possible, given vast computing power but an otherwise rich and complicated environment?</p><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Diamond maximizer</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="ai_alignment.html">AI alignment</a></li><li><a href="value_identification.html">Value identification problem</a></li><li><a href="ontology_identification.html">Ontology identification problem</a></li><li>â€¦</li></ul></nav></nav></header><hr><main><p>A difficult, far-reaching open problem in <a href="ai_alignment.html">AI alignment</a> is to specify an [ unbounded] formula for an agent that would, if run on an [ unphysically large finite computer], create as much diamond material as possible.  The goal of 'diamonds' was chosen to make it physically crisp as to what constitutes a 'diamond'.  Supposing a crisp goal plus hypercomputation avoids some problems in value alignment, while still invoking many others, making it an interesting intermediate problem.</p>
<h3 id="importance">Importance</h3>
<p>The diamond maximizer problem is to give an [ unbounded] description of a computer program such that, if it were instantiated on a sufficiently powerful but [ physical computer], the result of running the program would be the creation of an immense amount of diamond - around as much diamond as is physically possible for an agent to create.</p>
<p>The fact that this problem is still extremely hard shows that the value alignment problem is not just due to the <a href="complexity_of_value.html">Complexity of value</a>.  As a thought experiment, it helps to distinguish value-complexity-laden difficulties from those that arise even for simple goals.</p>
<p>It also helps to [ illustrate the difficulty of value alignment] by making the more clearly visible point that we can't even figure out how to create lots of diamond using unlimited computing power, never mind creating <a href="value_alignment_value.html">value</a> using [ bounded computing power].</p>
<h3 id="problemsavoided">Problems avoided</h3>
<p>If we can crisply define exactly what a 'diamond' is, in theory it seems like we should be able to avoid issues of <a href="edge_instantiation.html">Edge Instantiation</a>, <a href="unforeseen_maximum.html">Unforeseen Maximums</a>, and trying to convey <a href="complexity_of_value.html">complex values</a> into the agent.</p>
<p>The amount of diamond is defined as the number of carbon atoms that are covalently bonded, by electrons, to exactly four other carbon atoms.  A carbon atom is any nucleus containing six protons and any number of neutrons, bound by the strong force.  The utility of a universal history is the total amount of Minkowskian interval spent by all carbon atoms being bound to exactly four other carbon atoms.  More precise definitions of 'bound', or the amount of measure in a quantum system that is being bound, are left to the reader - any crisp definition will do, so long as we are confident that it has no <a href="unforeseen_maximum.html">unforeseen maximum</a> at things we don't intuitively see as diamonds.</p>
<h3 id="problemschallenged">Problems challenged</h3>
<p>Since this diamond maximizer would hypothetically be implemented on a very large but physical computer, it would confront [ reflective stability], the [ anvil problem], and the problems of making [ subagents].</p>
<p>To the extent the diamond maximizer might need to worry about other agents in the environment that have a good ability to model, or that it may need to cooperate with other diamond maximizers, it must resolve [ Newcomblike problems] using some [ logical decision theory].  This would also require it to confront [ logical uncertainty] despite possessing immense amounts of computing power.</p>
<p>To the extent the diamond maximizer must work well in a rich real universe that might operate according to any number of possible physical laws, it faces a problem of [ naturalized induction] and <a href="ontology_identification.html">ontology identification</a>.  See the article on <a href="ontology_identification.html">ontology identification</a> for the case that even for the goal of 'make diamonds', the problem of [ goal identification] remains difficult.</p>
<h3 id="unreflectivediamondmaximizer">Unreflective diamond maximizer</h3>
<p>As a further-simplified but still unsolved problem, an <strong>unreflective diamond maximizer</strong> is a diamond maximizer implemented on a [ Cartesian hypercomputer] in a [ causal universe] that does not face any [ Newcomblike problems].  This further avoids problems of reflectivity and logical uncertainty.  In this case, it seems plausible that the primary difficulty remaining is <em>just</em> the <a href="ontology_identification.html">ontology identification problem</a>.  Thus the open problem of describing an unreflective diamond maximizer is a central illustration for the difficulty of ontology identification.</p></main><hr><section class="comments"><h2>Comments</h2><div class="comment"><p><a class="page-link" href="../page/MalcolmOcean.html">Malcolm Ocean</a></p><p><blockquote class="comment-context">The amount of diamond is defined as the number of carbon atoms that are covalently bonded, by electrons, to exactly <mark>three other carbon atoms</mark>\.  A carbon atom is any nucleus containing six protons and any number of neutrons, bound by the strong force\.  The utility of a universal history is the total amount of Minkowskian interval spent by all carbon atoms being bound to exactly three other carbon atoms\.  More precise definitions of 'bound', or the amount of measure in a quantum system that is being bound, are left to the reader \- any crisp definition will do, so long as we are confident that it has no unforeseen maximum at things we don't intuitively see as diamonds\.</blockquote>
<p>Shouldn't this be four?</p>
<p><img src="http://www.chemactive.com/working2012/images/chemistryimages/diamond.png?0" alt="diamond molecular structure" /></p></p><div class="comment"><p><a class="page-link" href="../page/NateSoares.html">Nate Soares</a></p><p><p>Yep. Fixed, thanks.</p></p></div></div><div class="comment"><p><a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a></p><p><p>This seems like a good example to have at hand. I'm skeptical that it's much easier than what we really care about, but I guess we'll see (eventually).</p>
<p>Rather than a very big physical computer, it might be a bit easier to imagine a world full of (stochastic) hypercomputers that can solve their own (stochastic) evaluation problems, i.e. reflective oracles. This involves reflection but not computational limitations, so seems to capture a lot of what you care about without including the whole AI problem.</p></p></div></section><footer><p class="tagged"><h2>Tagged</h2><span class="page-comma-list"><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a></span></p><p class="all-creators"><h2>All Creators</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexeiAndreev.html">Alexei Andreev</a>,
 <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a>,
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a></span></p><p class="likes"><h2>Likes</h2><span class="page-comma-list"><a class="page-link" href="../page/AlexFlint.html">Alex Flint</a>,
 <a class="page-link" href="../page/AndrewMcKnight.html">Andrew McKnight</a>,
 <a class="page-link" href="../page/FlorentBerthet.html">Florent Berthet</a>,
 <a class="page-link" href="../page/JohnMaxwell.html">John Maxwell</a>,
 <a class="page-link" href="../page/NateSoares.html">Nate Soares</a>,
 <a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a>,
 <a class="page-link" href="../page/StephanieZolayvar.html">Stephanie Zolayvar</a></span></p><p class="reverse-related"><h2>Reverse Related</h2><ul class="page-list"><li><a class="page-link" href="../page/value_alignment_open_problem.html">AI alignment open problem</a> <q>Tag for open problems under AI alignment.</q> - <a class="page-link" href="../page/EliezerYudkowsky.html">Eliezer Yudkowsky</a></li></ul></p></footer></body></html>