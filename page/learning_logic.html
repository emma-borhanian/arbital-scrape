<!DOCTYPE html><html><head><meta charset="utf-8"><title>Learning and logic</title><link rel="stylesheet" type="text/css" href="../common.css"><link rel="stylesheet" type="text/css" href="../page-style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  SVG: {EqnChunk: 50, EqnChunkFactor: 1.5, EqChunkDelay: 10, useFontCache: false, linebreaks: {automatic: true}},
  tex2jax: {
    inlineMath: [['$~$', '$~$']],
    displayMath: [['$$~$', '$~$$']],
    processEscapes: true,
    preview: 'none',
  },
  showProcessingMessages: false,
  messageStyle: 'none',
  // http://docs.mathjax.org/en/latest/config-files.html#the-tex-ams-svg-configuration-file
  jax: ["input/TeX","output/SVG", "output/PreviewHTML"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
  TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }
});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_SVG" async></script><script type="text/javascript" src="../arbital-demo-bundle.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', e=>window.loadAllDemos())
</script></head><body><header><h1 class="title">Learning and logic</h1><div class="page-info"><p class="metadata-link"><a href="../metadata/learning_logic.json.html">learning_logic.json</a></p><p class="arbital-url"><a href="https://arbital.com/p/learning_logic">https://arbital.com/p/learning_logic</a></p><p class="creator">by
 <a class="page-link" href="../page/PaulChristiano.html">Paul Christiano</a> Feb 2 2016 
updated
 Mar 4 2016</p></div><nav class="breadcrumbs"><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="../index.html">Index</a></li><li>Learning and logic</li></ul></nav><nav class="breadcrumb" aria-label="Breadcrumb"><ul><li><a href="paul_ai_control.html">Paul Christiano's AI control blog</a></li><li>…</li></ul></nav></nav></header><hr><main><p>In most machine learning tasks, the learner maximizes a concrete, empirical performance measure: in supervised learning the learner maximizes its classification accuracy, in reinforcement learning the learner maximizes its reward. In order to maximize this reward, the learner has to be able to observe or compute it.</p>
<p>But sometimes we want our learner to discover some interesting fact about the world — e.g. to find the mass of the Higgs boson — and we have no external check to tell us whether it has succeeded.</p>
<p>Solving problems where we can’t tie success directly to observations seems quite difficult at the moment. And we can’t just throw bigger computers and more data at them without doing a bunch of&nbsp;<em>ad hoc</em> thinking or finding some new insight. So, relatively speaking, these tasks seem to be getting harder over time.</p>
<p>From an AI control perspective this is an important problem. In the long run, we really want to use machines for tasks where we can’t define success as a simple function of observations.</p>
<h3 id="wherelogiccomesin">Where logic comes in</h3>
<p>Reasoning about logic is one of the simplest possible examples of this challenge. Logic lets us state a goal very precisely, in a very simple language with very simple semantics. Yet, for now, I don’t think that we have effective techniques for pursuing symbolically defined goals.</p>
<h3 id="thechallenge">The challenge</h3>
<p>As a toy example, consider a program&nbsp;<em>f</em>&nbsp;that is simple to define but prohibitively difficult to evaluate.&nbsp;<em>f</em>&nbsp;takes two binary arguments, and outputs either 0 or 1. Given an input&nbsp;<em>x</em>, we would like to find an input&nbsp;<em>y</em> such that&nbsp;<em>f</em>(<em>x, y</em>) = 1.</p>
<p>This problem is very closely related to estimating the probabilities of the form “<em>f</em>(<em>x, y</em>) = 1.”</p>
<p>If&nbsp;<em>f</em>&nbsp;is easy to evaluate, then we can treat this as a standard reinforcement learning problem. But as&nbsp;<em>f</em>&nbsp;gets more complicated, this becomes impractical, and we need some new technique.</p>
<p>I don’t know any reasonable algorithm for this problem.</p>
<p>Note that the&nbsp;<em>goal</em>&nbsp;is entirely logical, but the actual problem need not be purely abstract. Even an agent with a simple logical goal can benefit from having lots of data about the world. For a very simple example, you might learn that a calculator is a useful guide to facts about arithmetic. I think that using such observations is quite important.</p>
<h3 id="standards">Standards</h3>
<p>What do we mean by “reasonable algorithm”? We don’t necessarily need to pin this down — better algorithms are better— but if I want to argue that there is an important gap in our knowledge, I need to say something about what we don’t yet know.</p>
<p>I’m interested in&nbsp;<em>frameworks</em>&nbsp;for symbolic reasoning, that combine available building blocks to solve the problem. Then the goal is scalable frameworks that can effectively exploit continuing improvements in optimization algorithms, or increased hardware, or conceptual advances AI.</p>
<p>Some desiderata:</p>
<ul>
<li>Whatever level of performance on logical tasks we can achieve implicitly in the process of solving RL or supervised learning problems, we ought to be able to achieve similar performance on the logical problems themselves. For example, if our reinforcement learner can form a plan in an environment, then our logical reasoner ought to be able to solve an analogous constraint satisfaction problem. If our reinforcement learner can argue persuasively that a theorem is true in order to win a reward, then our logical reasoner ought to be able to assign high probability to it.</li>
<li>Similarly, if we can achieve human-level performance on all RL problems, including complex problems requiring the full range of human abilities, we ought to be able to compute probabilities that are as accurate as those assigned by a human.</li>
</ul>
<p>These standards are very imprecise (e.g. what does it mean for an RL problem to “implicitly” require solving some logical task?), but hopefully it gives a sense of what I am after.</p>
<p>I think that we can’t meet this requirement yet, certainly not in a way that will continue to hold as underlying optimization algorithms and computational hardware improve. (See the next section on inadequate approaches.)</p>
<h3 id="whylogicisespeciallyinteresting">Why logic is especially interesting</h3>
<p>Logic isn’t just the simplest toy example; it is also an extremely expressive language. With enough additional work I think that we might be able to <a href="https://ordinaryideas.wordpress.com/2012/04/21/indirect-normativity-write-up/">define a reasonable proxy for our actual preferences</a>&nbsp;as a logical expression. (Though like most people I expect it will be practically easier to use a language that can easily represent things like “the user,” which are kind of a mouthful in formal logic.) The problem is “merely” that the logical definition is hopelessly complex.</p>
<p>Whether or not you buy this particular argument, I think that much of the “hard part” of reasoning symbolically already appears in the context of reasoning about very complex logical expressions. Thinking about logic simplifies the general problem of symbolic reasoning, by providing us with semantics “for free.” But I think we are still left with a very important problem.</p>
<h1 id="someinadequateresponsestothechallenge">Some inadequate responses to the challenge</h1>
<h3 id="logicasarepresentation">Logic as a representation</h3>
<p>I can already build a theorem-proving system, that analyzes a sentence φ by searching for proofs of φ. I can maybe even&nbsp;<a href="https://intelligence.org/files/Non-Omniscience.pdf">up the ante</a>&nbsp;by assigning probabilities to sets of sentences, and defining procedures for updating these probabilities on “logical observations.”</p>
<p>These approaches lag radically behind the current state of the art for supervised learning.</p>
<p>One basic problem is that logic is the language of our problem statement, and logical deduction is indeed powerful, but it is often a&nbsp;<em>terrible</em>&nbsp;internal representation. For example, if I am told some facts about a linear order on X, Y, Z, I should probably represent those facts by putting X, Y, Z on a line rather than by explicitly representing every inequality.</p>
<p>We would really like to design algorithms that can efficiently learn whatever internal representation is most effective. Similarly, we’d like to allow our algorithms to learn what approach to logical inference is most appropriate. And in general, approaches which embed logical structure via hand-coded rules (and then lean on those rules to actually do meaningful computational work) look like they may be on the wrong side of the history.</p>
<p>Moreover, if we are searching for a scalable framework, these approaches obviously won’t cut if. At best we will end up with a “race” between algorithms for logical reasoning and other AI systems.</p>
<h3 id="transferlearning">Transfer learning</h3>
<p>A second approach is to treat logical reasoning as a supervised learning problem. That is, we can sample sentences φ, ask our learner to guess whether they are true, and then adjust the model to assign higher probability to the correct guess (e.g. to maximize log score).</p>
<p>The key difficulty with this approach is that we can only train on sentences φ which are sufficiently simple that we can actually tell whether they are true or false.</p>
<p>In order to apply the learned model to complex sentences, we need to rely on a strong form of transfer learning. Namely, we need to take a model which has had&nbsp;<em>zero</em>&nbsp;training on sentences that are too-complex-to-evaluate, and trust it to perform well on such sentences. I am somewhat skeptical about expecting learning algorithms to reliably generalize to a new domain where it is impossible to even tell whether they are generalizing correctly.</p>
<p>Ideally we would be able to train our algorithm on exactly the kinds of sentences that we actually cared about. But this easy vs. hard distinction probably means that we would have to train our system exclusively on much easier toy samples.</p>
<p>I think that this kind of generalization is plausible for simple functions (e.g. multiplication). But assigning probabilities to logical sentences is definitely&nbsp;<em>not</em>&nbsp;a simple function; it draws on a wide range of cognitive capabilities, and the actual estimator is extremely complex and messy. I would be completely unsurprised to find that many models which perform well on easy-to-assess sentences have pathological behavior when extended to very challenging sentences.</p>
<p>At some point I might be convinced that AI control inherently needs to rest on assumptions about transfer learning — that we have no hope but to hope that learned functions generalize in the intended way to unforeseen situations. But I haven’t yet given up — for now, I still think that we can solve the problem without any leaps of faith.</p>
<p>Pragmatically, if we wanted to train a function to estimate the truth of complex sentences, we might train it on our “best guesses” about the truth of complex sentences that we couldn’t answer exactly. But we’ll end up with a supervised learning system that estimates our best guesses about logical facts. This doesn’t really buy us anything from a control perspective.</p>
<h1 id="apreliminaryapproach">A preliminary approach</h1>
<p>I’m going to describe an extremely preliminary approach to this problem. It seems far from satisfactory; my purpose is mostly to raise the question and show that we can get at least a little bit of traction on it.</p>
<h3 id="thescheme">The scheme</h3>
<p>We’ll train a function&nbsp;<em>P</em>&nbsp;to assign probabilities to logical sentences. For simplicity we’ll work with a language that has constant, function, and relation symbols, variables, and no quantifiers. Variables are assumed to be universally quantified.</p>
<p>(I’m not really going to talk about how the function is trained or what class of models is used. I just want to use&nbsp;<em>P</em>&nbsp;as a black box for the online learning problem I’m going to describe. For concreteness you could imagine training a neural network to recursively build a constant-sized vector representation of formulas or terms by combining representations for each subexpression. Probably an algorithm which could actually handle this problem would need to advance the state of the art in several important ways.)</p>
<p>At the same time we will train a reinforcement learner&nbsp;<em>A</em> to produce “challenges” to&nbsp;<em>P</em>:&nbsp;<em>A</em>’s goal is to identify inconsistencies in&nbsp;<em>P</em>’s probabilities.</p>
<p>I’ll also assume we have some&nbsp;<em>observations</em> φᵢ, logical facts which are observed to be true. Over time the set of observations will grow.</p>
<p>I’ll allow four kinds of challenges from&nbsp;<em>A</em>, corresponding to four kinds of possible inconsistencies.</p>
<ol>
<li>Given any pair of sentences φ, ψ, a consistent assignment of probabilities to sentences should have:&nbsp;<em>P</em>(φ) =&nbsp;<em>P</em>(φ ∧ ψ) +&nbsp;<em>P</em>(φ ∧<em>¬</em>ψ).</li>
<li>Given any sentence φ with a free variable&nbsp;<em>x</em>, and any term&nbsp;<em>t</em>, we should have&nbsp;<em>P</em>(φ ∧ φ[_x_&nbsp;:=&nbsp;_t_]) =&nbsp;<em>P</em>(φ).</li>
<li>Given any sentence φ and a sentence ψ which is “obviously” equivalent to on φ, we should have&nbsp;<em>P</em>(φ) =&nbsp;<em>P</em>(ψ). I won’t define “obviously,” but we could use the notion of&nbsp;<em>trivial equivalence</em>&nbsp;from&nbsp;<a href="https://intelligence.org/files/Non-Omniscience.pdf">here</a>.</li>
<li>Given any observation φᵢ, we should have&nbsp;<em>P</em>(φᵢ) = 1.</li>
</ol>
<p><em>A</em>’s goal is to produce a pair of sentences, or a sentence and a term, such that&nbsp;<em>P</em>&nbsp;violates one of these constraints.</p>
<p>It turns out that these constraints are universal: If&nbsp;<em>P</em>&nbsp;doesn’t violate any of these constraints, then we can prove that&nbsp;<em>P</em>’s assignments actually correspond to some distribution over models consistent with observation. In reality,&nbsp;<em>P</em>&nbsp;will never converge to a distribution that satisfies all of these constraints.</p>
<p>Formally,&nbsp;<em>A</em>&nbsp;and&nbsp;<em>P</em>&nbsp;play the following game:</p>
<ul>
<li><em>A</em>&nbsp;chooses a consistency check from one of categories 1–4 above. We may put some limits on what sentences it can use in a consistency check — for example, to implement curriculum learning, we may initially limit&nbsp;<em>A</em>&nbsp;to providing short sentences.</li>
<li><em>P</em>&nbsp;assigns probabilities to each sentence referenced in the consistency check. (The same program is used to assign a probability to each sentence. Intuitively, separate copies of&nbsp;<em>P</em>&nbsp;independently assign a probability to each sentence.)</li>
<li>If&nbsp;<em>P</em>’s probabilities are inconsistent, then we penalize&nbsp;<em>P</em> (and reward&nbsp;<em>A</em>). A natural choice for penalty is the total KL divergence from&nbsp;<em>P</em>’s probabilities to the closest consistent set of probabilities.</li>
</ul>
<p><em>A</em>&nbsp;is trained to maximize&nbsp;<em>P</em>’s penalty in the next round (i.e. without concern for effects on future rounds), and&nbsp;<em>P</em>&nbsp;is trained to minimize its penalty.</p>
<h3 id="exampleonlyobservations">Example: Only observations</h3>
<p>If&nbsp;<em>A</em>&nbsp;only ever makes challenges of type 4 — enforcing consistency with an observation — then&nbsp;<em>P</em>&nbsp;is free to ignore logical structure. In this case, the procedure corresponds to supervised learning. So at least we have successfully subsumed the simple supervised learning approach.</p>
<p>All of the system’s ability to reason about complex sentences is coming from the consistency checks.</p>
<p>The consistency mechanism is more general than the observations. For example, by carrying out the steps of a computation one by one,&nbsp;<em>A</em>&nbsp;can force&nbsp;<em>P</em>&nbsp;to be correct about the result of that computation. The observations are only relevant if either there are constant symbols in the language, or we are relying on the environment to do interesting computations.</p>
<p>So, even if we left out the observations, as long as&nbsp;<em>A</em>&nbsp;followed an appropriate strategy, this system would still subsume the simple supervised learning approach. (<em>A</em>’s strategy is obviously very important, see the section “Problem: Relevance” below.)</p>
<h3 id="examplenostructure">Example: No structure</h3>
<p><em>P</em> is free to ignore all structure of logical sentences, and only use the constraints implied by&nbsp;<em>A</em>’s challenges. For example,&nbsp;<em>P</em>&nbsp;could use the following procedure:</p>
<p>Notice that each constraint is linear, so that the set of constraints appearing&nbsp;<em>A</em>’s challenges form a polytope (which is simply the whole space [0, 1] in any coordinate that hasn’t yet appeared in a constraint).&nbsp;<em>P</em>&nbsp;can track each of these constraints, and in each round output the appropriate coordinate of the centroid of this polytope.</p>
<p>(This basically looks like constraint generation, though it’s not going to go anywhere good ever because&nbsp;<em>P</em>&nbsp;can never converge — see the next section.)</p>
<p>On this model,&nbsp;<em>P</em>&nbsp;and&nbsp;<em>A</em>&nbsp;together are essentially doing elementary logical inference. The whole definition of the system resides in&nbsp;<em>A</em>’s choices about what to explore, which is playing the role of the proposer in a proof search.</p>
<h3 id="problemrelevance">Problem: Relevance</h3>
<p>There will always be inconsistencies in&nbsp;<em>P</em>’s probabilities, and&nbsp;<em>A</em>&nbsp;will always be able to find some of them. So&nbsp;<em>P</em>&nbsp;can never really win the game, and the training will continuously patch new problems identified by&nbsp;<em>A</em> rather than ever converging. Our only guarantee will be that&nbsp;<em>P</em> is consistent&nbsp;<em>for the kinds of questions that A prefers to ask</em>.</p>
<p>So it really matters that&nbsp;<em>A</em>&nbsp;asks relevant questions. But so far we haven’t said anything about that, we have just given&nbsp;<em>A</em>&nbsp;the goal of identifying inconsistencies in&nbsp;<em>P</em>’s view. I think that this is the most important deficiency in the scheme — without correcting it, the whole thing is useless.</p>
<p>For simplicity, let’s assume that we are ultimately interested in a particular sentence φ. We would like&nbsp;<em>A</em>&nbsp;to focus on questions that are most relevant to φ, such that if&nbsp;<em>P</em>&nbsp;is consistent on these sentences then it is especially likely to have a reasonable view about φ.</p>
<p>A crude approach is to simply reward&nbsp;<em>A</em> for asking questions which are correlated with φ (according to&nbsp;<em>P</em>). For example, when&nbsp;<em>P</em>&nbsp;is penalized on some sentence we can reward&nbsp;<em>A</em>&nbsp;according to the product [how much&nbsp;<em>P</em>’s beliefs about ψ had to move to be consistent]  [the mutual information between ψ and φ, according to&nbsp;<em>P</em>]. The hope is that questions which are relevant to φ will be correlated with φ, and so&nbsp;<em>A</em>&nbsp;will focus its attention on <em>P</em>’s most relevant errors. But there is no real principled reason to think that this would work.</p>
<p>Alternatively, we could train a relevance function&nbsp;<em>V</em>&nbsp;in parallel with&nbsp;<em>A</em>&nbsp;and <em>P</em>. The simplest instantiation of this idea might be to require&nbsp;<em>V</em>(φ) = 1, and to require that&nbsp;<em>V</em>(ψ) be large whenever ψ is logically related, or perhaps has high mutual information under&nbsp;<em>P</em>, to another sentence with a high relevance. (and to otherwise exert downward pressure on&nbsp;<em>V</em>). We could then reward&nbsp;<em>A</em>&nbsp;for choosing highly relevant sentences. This has a similar intuitive motivation, but it also lacks any principled justification.</p>
<p>Another crude measure is to reward&nbsp;<em>A</em>&nbsp;for identifying errors involving simple sentences, so that&nbsp;<em>P</em>&nbsp;will be roughly consistent whenever we talk about simple sentences, and it will “notice” any arguments that involve only simple sentences. This can’t be a substitute for relevance though, since it requires&nbsp;<em>P</em>&nbsp;to notice&nbsp;<em>all</em>&nbsp;of these arguments rather than allowing it to focus on the relevant ones.</p>
<p>I don’t see any easy way to deal with this problem. That may mean that this approach to logical reasoning is doomed. Or it just might mean that we need a clever idea — I think there is a lot to try.</p>
<h3 id="problemgoingbeyondlogic">Problem: going beyond logic</h3>
<p>In this scheme, consistency checks are limited to logical consistency conditions. In some sense these conditions are universal if we only care about finite objects. But they may be less powerful than other kinds of inference.</p>
<p>Of course,&nbsp;<em>A</em>&nbsp;and&nbsp;<em>P</em> can learn strategies that reflect more complex regularities. For example,&nbsp;<em>P</em>&nbsp;can learn that probabilistic methods usually work, and thereafter use probabilistic methods to guess whether a sentence is true. And&nbsp;<em>A</em>&nbsp;can learn that probabilistic methods usually work, and thereafter use them to identify probable inconsistencies in&nbsp;<em>P</em>’s views.</p>
<p>But these other methods of inference can’t be used to generate extra constraints on&nbsp;<em>P</em>’s beliefs, and that may mean that the resulting beliefs are less accurate than human beliefs (even if&nbsp;<em>P</em>&nbsp;is much better at reinforcement learning than a human).</p>
<p>It’s not clear whether this is a big problem.</p>
<p>To see an example where this looks like it could be a problem, but actually isn’t: consider an agent reasoning about arithmetic in without logical induction. Suppose that&nbsp;<em>P</em>&nbsp;assigns a high probability to ∀<em>n</em>: φ(<em>n</em>) → φ(<em>n</em>+1), and assigns a high probability to φ(0), yet assigns a low probability to φ(1000000). At face value,&nbsp;<em>A</em>&nbsp;has no way to prove that&nbsp;<em>P</em>&nbsp;is inconsistent. Thus&nbsp;<em>P</em>&nbsp;might be able to persist in these inconsistent beliefs, even if&nbsp;<em>P</em>&nbsp;and&nbsp;<em>A</em>&nbsp;are both good enough learners that they would be able to figure out the induction is useful.</p>
<p>But&nbsp;<em>A</em>&nbsp;can use induction in order to identify a problem in&nbsp;<em>P</em>’s beliefs, by doing a binary search to find a point where&nbsp;<em>P</em> has different beliefs about φ(<em>n</em>) and φ(<em>n</em>+1), even conditioned on ∀<em>n</em>: φ(<em>n</em>) → φ(<em>n</em>+1).</p>
<p>So in fact we didn’t need to include induction as an inference rule for&nbsp;<em>A</em>, it falls naturally out of the rules of the game. (You might complain that the size of&nbsp;<em>P</em>’s inconsistency is significantly decreased, but a more clever strategy for&nbsp;<em>A</em>&nbsp;can ensure that the reduction is at-most-linear.)</p>
<p>It seems like this is probably a happy coincidence, distinctive to induction. In general, we can probably find axioms such that&nbsp;<em>P</em>&nbsp;doesn’t lose anything by simply violating them. Even if&nbsp;<em>P</em> “can tell” that such an axiom is true, but has no incentive to assign it a high probability. Similarly, using that axiom <em>A</em> can identify likely inconsistencies in&nbsp;<em>P</em>’s beliefs, but has no way to quickly demonstrate an inconsistency.</p>
<p>And of course,&nbsp;<em>A</em>&nbsp;and&nbsp;<em>P</em>&nbsp;probably make judgments that don’t correspond to any axioms at all, e.g. based on statistical regularities or alternative representations that give probabilistic clues.</p>
<p>In some sense, the problem is that we have a “dumb” arbiter, who only accepts proofs of inconsistency of a very restricted kind. If we want our system to learn to give human-level judgments, we need to either:</p>
<ul>
<li>Show that such a “dumb” arbiter is sufficient, and provides essentially the maximal possible pressure on&nbsp;<em>P</em>’s beliefs.</li>
<li>Change the setup to make the arbiter’s job easier, so that a dumb arbiter can do it after all.</li>
<li>Describe a more clever set of consistency checks which is in some sense universal and lets&nbsp;<em>A</em>&nbsp;make any kind of inconsistency argument that&nbsp;<em>A</em> might want to make. This is in some sense analogous to specifying&nbsp;<em>P</em> directly rather than using learning, but maybe the arbiter’s job is much easier than the learner’s job.</li>
<li>Allow the arbiter itself to learn without compromising correctness.</li>
</ul>
<p>A natural way to get around this problem is to use human evaluations to train an arbiter to evaluate consistency. This also allows us to give&nbsp;<em>P</em> a much larger class of questions (any questions that are meaningful to a human). In some sense this seems quite promising, but it introduces a few difficulties:</p>
<ul>
<li>From a safety perspective, if&nbsp;<em>A</em>&nbsp;is very powerful then we have reintroduced the kind of adversarial dynamic that symbolic reasoning may have let us avoid (since now&nbsp;<em>A</em>&nbsp;is incentivized to manipulate or deceive the human into judging in its favor). This might not be a critical failure; for example, a weak&nbsp;<em>A</em>&nbsp;and&nbsp;<em>P</em>&nbsp;can be used to build a more powerful human-aligned agent (which can then play the role of&nbsp;<em>A</em> or&nbsp;<em>P</em>&nbsp;in a still more powerful system,&nbsp;<em>etc.</em>)</li>
<li>Practically, logic is convenient because consistency is all-or-nothing, and so we don’t have to worry about quantitatively weighing up different partial inconsistencies. Once we move to a more realistic domain, this becomes a critical issue. It looks quite challenging.</li>
</ul>
<p>This problem is not as clear a deal-breaker as the issue with relevance discussed in the last section. But it seems like a more fundamental problem, and so maybe worth attacking first.</p>
<h1 id="relatedwork">Related work</h1>
<p>I am not aware of any existing work which tries to handle logical reasoning in what I’m calling a “scalable” way.</p>
<p>There is a literature on probabilistic logical reasoning, but mostly it fits in the category of “logic as a representation” above. This work mostly isn’t aiming to build systems that scale as effectively supervised learning. The flavor of the work ends up being very different.</p>
<p>There is a much smaller literature applying machine learning to this kind of logical problem. What work there is has been very happy to focus on the supervised learning approach, explicitly restricting attention to “easy” sentences where we can easily compute the ground truth or the quality of a proposed solution.</p>
<p>One reason for the lack of practical work is that existing machine learning techniques aren’t really strong enough for it to seem worthwhile. My guess is that the situation will change and is already starting to change, but for now there isn’t too much.</p>
<p>Researchers at&nbsp;<a href="https://intelligence.org/">MIRI</a>&nbsp;have thought about these questions at some length, and I thought about them a few years ago, but from a different angle (and with a different motivation). They have instead been focusing on finding improvements to existing intractable or impractical algorithms. Even in the infinite computing case we don’t have especially good models of how to solve this problem.</p>
<p>I’m now approaching the problem from a different angle, with a focus on efficacy rather than developing a “clean” theory of reasoning under logical uncertainty, for a few reasons:</p>
<ol>
<li>It’s not clear to me there is any clean theory of reasoning under logical uncertainty, and we already have a mediocre theory. It’s no longer obvious what additional theorems we want. This seems bad (though certainly not fatal).</li>
<li>It is pretty clear that there needs to be a more effective approach to symbolic reasoning, if it is to play any practical role in AI systems. So we know what the problem is.</li>
<li>The scalable symbolic reasoning problem looks much more important if AI control becomes a serious issue soon. Trying to solve it also looks like it will yield more useful information (in particular, this is probably the main uncertainty about the role of logic in practical AI systems).</li>
<li>Given that we understand the constraints from efficacy, and don’t understand the constraints from having a clean theory, I think that thinking about efficacy is more likely to improve our thinking about the clean theory than vice versa.</li>
</ol></main><hr><footer></footer></body></html>